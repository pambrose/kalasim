{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to kalasim kalasim is a discrete event simulator that enables complex, performant, dynamic process models. It provides a statically typed API, dependency injection, modern persistence, structured logging and automation capabilities. kalasim is designed for simulation practitioners, process analysts and industrial engineers, who need to go beyond the limitations of existing simulation tools to model and optimize their business-critical use-cases. In contrast to many other simulation tools, kalasim is neither low-code nor no-code. It is code-first to enable change tracking, scaling, refactoring, CI/CD, unit-tests, and the rest of the gang that makes simulation development fun. kalasim is written in Kotlin , is designed around suspendable coroutines for process definitions, runs on the JVM for performance and scale, is built with koin as dependency wiring framework, and is using common-math for stats and distributions. See acknowledgements for further references. kalasim is agnostic regarding a visualization frontend, but we provide bindings/examples using plotly.kt , lets-plot as well as kravis . Core Features kalasim is a generic process-oriented discrete event simulation (DES) engine. Simulation entities have a generative process description that defines the interplay with other entities There is a well-defined rich process interaction vocabulary, including hold , request , wait or passivate An event trigger queue maintains future action triggers and acts as sole driver to progress simulation state Built-in monitoring and statistics gathering across the entire API Find out more about the basics of a kalasim simulation. First Example Let\u2019s start with a very simple model. The example demonstrates the main mode of operation, the core API and the component process model implemented in kalasim . We want to build a simulation where a single car is driving around for a some time before stopping in front of a red traffic light. ////Cars.kts import org.kalasim.* class Driver : Resource () class TrafficLight : State < String > ( \"red\" ) class Car : Component () { val trafficLight = get < TrafficLight > () val driver = get < Driver > () override fun process () = sequence { request ( driver ) { hold ( 1.0 , description = \"driving\" ) wait ( trafficLight , \"green\" ) } } } createSimulation ( enableConsoleLogger = true ) { dependency { TrafficLight () } dependency { Driver () } Car () }. run ( 5.0 ) Curious about an in-depth analysis of this example? It's your lucky day, see here . How to contribute? Feel welcome to post ideas and suggestions to the project tracker . We always welcome pull requests. :-) Support Feel welcome to post questions and ideas in the project's gitter chat Feel also invited to chat with us in the kotlinlang.slack.com in the #kalasim channel.","title":"Introduction"},{"location":"#welcome-to-kalasim","text":"kalasim is a discrete event simulator that enables complex, performant, dynamic process models. It provides a statically typed API, dependency injection, modern persistence, structured logging and automation capabilities. kalasim is designed for simulation practitioners, process analysts and industrial engineers, who need to go beyond the limitations of existing simulation tools to model and optimize their business-critical use-cases. In contrast to many other simulation tools, kalasim is neither low-code nor no-code. It is code-first to enable change tracking, scaling, refactoring, CI/CD, unit-tests, and the rest of the gang that makes simulation development fun. kalasim is written in Kotlin , is designed around suspendable coroutines for process definitions, runs on the JVM for performance and scale, is built with koin as dependency wiring framework, and is using common-math for stats and distributions. See acknowledgements for further references. kalasim is agnostic regarding a visualization frontend, but we provide bindings/examples using plotly.kt , lets-plot as well as kravis .","title":"Welcome to kalasim"},{"location":"#core-features","text":"kalasim is a generic process-oriented discrete event simulation (DES) engine. Simulation entities have a generative process description that defines the interplay with other entities There is a well-defined rich process interaction vocabulary, including hold , request , wait or passivate An event trigger queue maintains future action triggers and acts as sole driver to progress simulation state Built-in monitoring and statistics gathering across the entire API Find out more about the basics of a kalasim simulation.","title":"Core Features"},{"location":"#first-example","text":"Let\u2019s start with a very simple model. The example demonstrates the main mode of operation, the core API and the component process model implemented in kalasim . We want to build a simulation where a single car is driving around for a some time before stopping in front of a red traffic light. ////Cars.kts import org.kalasim.* class Driver : Resource () class TrafficLight : State < String > ( \"red\" ) class Car : Component () { val trafficLight = get < TrafficLight > () val driver = get < Driver > () override fun process () = sequence { request ( driver ) { hold ( 1.0 , description = \"driving\" ) wait ( trafficLight , \"green\" ) } } } createSimulation ( enableConsoleLogger = true ) { dependency { TrafficLight () } dependency { Driver () } Car () }. run ( 5.0 ) Curious about an in-depth analysis of this example? It's your lucky day, see here .","title":"First Example"},{"location":"#how-to-contribute","text":"Feel welcome to post ideas and suggestions to the project tracker . We always welcome pull requests. :-)","title":"How to contribute?"},{"location":"#support","text":"Feel welcome to post questions and ideas in the project's gitter chat Feel also invited to chat with us in the kotlinlang.slack.com in the #kalasim channel.","title":"Support"},{"location":"about/","text":"About License kalasim is licensed under MIT License. Acknowledgements salabim kalasim started off as a blunt rewrite of salabim . We are deeply thankful for its permissive licence that enabled setting up kalasim . A great starting point was in particular the wonderful article salabim: discrete event simulation and animation in Python . salabim s excellent documentation and wonderful examples made this project possible after all. kalasim reimplements all core APIs of salabim in a more typesafe API while also providing better test coverage, real-time capabilities and (arguably) more modern built-in support for visualization. Salabim, Discrete Event Simulation In Python - PyCon 2018 Talk Python. init Podcast: Salabim - Great podcast episode with Ruud van der Ham simmer simmer is a process-oriented and trajectory-based Discrete-Event Simulation (DES) package for R. It centres around the concept of a trajectory that defines a component lifecycle. To enable scale it is built on top of Rcpp (C++ backend for R). Great overview simmer: Discrete-Event Simulation for R , Ucar et al., 2019 Support for optimization in simmer.optim We have adopted several examples and documentation bits from simmer , and are deeply grateful to the simmer developers for providing such a great and well maintained tool. simmer has also been a great source of inspiration to implement in particular the monitoring and visualization API of kalasim . SimJulia SimJulia is a combined continuous time / discrete event process oriented simulation framework written in Julia inspired by the Simula library DISCO and the Python library SimPy. We have adopted several examples and documentation bits from SimJulia , and are deeply grateful its developers for providing such a great and well maintained tool. SimPy SimPy is a process-based discrete-event simulation framework based on standard Python. Processes in SimPy are defined by Python generator functions. SimPy also provides various types of shared resources to model limited capacity congestion points (like servers, checkout counters and tunnels). We have adopted several examples and documentation bits from SimPy , and are deeply grateful its developers for providing such a great and well maintained tool. DSOL DSOL3 which is an open source, Java based suite of Java classes for continuous and discrete event simulation The wonderful DSOL manual The DSOL simulation suite - Enabling multi-formalism simulation in a distributed context , PhD Thesis, Peter Jacobs, 2005 Mastering D-SOL: A Java based suite for simulation with several examples, 2006 opentrafficsim is a traffic simulation built with DSOL3 Libraries used to build kalasim kalasim is built on top of some great libraries. It was derived as merger of ideas, implementation and documentation from the following projects: Kotlin - Not really a library, but for obvious reasons the foundation of this project koin which is a pragmatic lightweight dependency injection framework for Kotlin developers Apache Commons Math is a library of lightweight, self-contained mathematics and statistics components jsonbuilder is a small artifact that serves a single purpose: It allows creating json using an idiomatic kotlin DSL. Its main purpose it to make sure kalasim provides a machine-readable log-format for all basics in a simulation. kotest.io is a flexible and elegant multiplatform test framework, assertions library, and property test library for Kotlin. We use it to make sure kalasim fulfils its component contract. Visualization https://github.com/holgerbrandl/kravis which implements a grammar to create a wide range of plots using a standardized set of verbs Repo Maintainer Holger Brandl holds a Ph.D. degree in machine learning and has developed new concepts in the field of computational linguistics. More recently he has co-authored publications in high-ranking journals such as Nature and Science. To stay in sync with what's happening in tech, he's developing open-source tools, methods and algorithms for bioinformatics, high-performance computing and data science. He's passionate about machine learning, AI, analytics, elegant APIs and data visualisation. His professional scope mainly centers around systems biology and industrial manufacturing.","title":"About"},{"location":"about/#about","text":"","title":"About"},{"location":"about/#license","text":"kalasim is licensed under MIT License.","title":"License"},{"location":"about/#acknowledgements","text":"","title":"Acknowledgements"},{"location":"about/#salabim","text":"kalasim started off as a blunt rewrite of salabim . We are deeply thankful for its permissive licence that enabled setting up kalasim . A great starting point was in particular the wonderful article salabim: discrete event simulation and animation in Python . salabim s excellent documentation and wonderful examples made this project possible after all. kalasim reimplements all core APIs of salabim in a more typesafe API while also providing better test coverage, real-time capabilities and (arguably) more modern built-in support for visualization. Salabim, Discrete Event Simulation In Python - PyCon 2018 Talk Python. init Podcast: Salabim - Great podcast episode with Ruud van der Ham","title":"salabim"},{"location":"about/#simmer","text":"simmer is a process-oriented and trajectory-based Discrete-Event Simulation (DES) package for R. It centres around the concept of a trajectory that defines a component lifecycle. To enable scale it is built on top of Rcpp (C++ backend for R). Great overview simmer: Discrete-Event Simulation for R , Ucar et al., 2019 Support for optimization in simmer.optim We have adopted several examples and documentation bits from simmer , and are deeply grateful to the simmer developers for providing such a great and well maintained tool. simmer has also been a great source of inspiration to implement in particular the monitoring and visualization API of kalasim .","title":"simmer"},{"location":"about/#simjulia","text":"SimJulia is a combined continuous time / discrete event process oriented simulation framework written in Julia inspired by the Simula library DISCO and the Python library SimPy. We have adopted several examples and documentation bits from SimJulia , and are deeply grateful its developers for providing such a great and well maintained tool.","title":"SimJulia"},{"location":"about/#simpy","text":"SimPy is a process-based discrete-event simulation framework based on standard Python. Processes in SimPy are defined by Python generator functions. SimPy also provides various types of shared resources to model limited capacity congestion points (like servers, checkout counters and tunnels). We have adopted several examples and documentation bits from SimPy , and are deeply grateful its developers for providing such a great and well maintained tool.","title":"SimPy"},{"location":"about/#dsol","text":"DSOL3 which is an open source, Java based suite of Java classes for continuous and discrete event simulation The wonderful DSOL manual The DSOL simulation suite - Enabling multi-formalism simulation in a distributed context , PhD Thesis, Peter Jacobs, 2005 Mastering D-SOL: A Java based suite for simulation with several examples, 2006 opentrafficsim is a traffic simulation built with DSOL3","title":"DSOL"},{"location":"about/#libraries-used-to-build-kalasim","text":"kalasim is built on top of some great libraries. It was derived as merger of ideas, implementation and documentation from the following projects: Kotlin - Not really a library, but for obvious reasons the foundation of this project koin which is a pragmatic lightweight dependency injection framework for Kotlin developers Apache Commons Math is a library of lightweight, self-contained mathematics and statistics components jsonbuilder is a small artifact that serves a single purpose: It allows creating json using an idiomatic kotlin DSL. Its main purpose it to make sure kalasim provides a machine-readable log-format for all basics in a simulation. kotest.io is a flexible and elegant multiplatform test framework, assertions library, and property test library for Kotlin. We use it to make sure kalasim fulfils its component contract. Visualization https://github.com/holgerbrandl/kravis which implements a grammar to create a wide range of plots using a standardized set of verbs","title":"Libraries used to build kalasim"},{"location":"about/#repo-maintainer","text":"Holger Brandl holds a Ph.D. degree in machine learning and has developed new concepts in the field of computational linguistics. More recently he has co-authored publications in high-ranking journals such as Nature and Science. To stay in sync with what's happening in tech, he's developing open-source tools, methods and algorithms for bioinformatics, high-performance computing and data science. He's passionate about machine learning, AI, analytics, elegant APIs and data visualisation. His professional scope mainly centers around systems biology and industrial manufacturing.","title":"Repo Maintainer"},{"location":"advanced/","text":"Clock Synchronization In simulation a clear distinction is made between real time and simulation time. With real time we refer to the wall-clock time. It represents the execution time of the experiment. The simulation time is an attribute of the simulator. To support use cases where a simulation may drive a demonstration or system check, the kalasim API allows to run a simulation at a defined clock speed. Such real-time simulations may be necessary If you have hardware-in-the-loop If the intent of the simulation is to drive a visualization of a process If there is human interaction with your simulation, or If you want to analyze the real-time behavior of an algorithm import org.kalasim.ClockSync import org.kalasim.createSimulation import java.time.Duration val timeBefore = System . currentTimeMillis () createSimulation ( true ) { // enable real-time clock synchronization w ClockSync ( tickDuration = Duration . ofSeconds ( 1 )) // enable real-time clock synchronization but run in 2x realtime // ClockSync(Duration.ofSeconds(1), speedUp = 2) run ( 10 ) } println ( \"time passed ${ System . currentTimeMillis () - timeBefore } )\" ) This example will execute in 10 seconds. Since the simulation is empty (for educational reasons to keep the focus on the clock here), it is entirely idle during that time. To enable clock synchronization, we need to add a ClockSync to our simulation. We need to define what one tick in simulation time corresponds to in wall time. In the example, one tick equals to one second wall time. This is configured with the parameter tickDuration . It defines the duration of a simulation tick in wall clock coordinates. It can be created with Duration.ofSeconds(1) , Duration.ofMinutes(10) and so on . ClockSync also provides settings for more advanced uses-cases To run simulations, in more than realtime, the user can specify speedUp to run a simulation faster ( speedUp > 1) or slower ( speedUp < 1) than realtime. It defaults to 1 , that is no speed-up will be applied. The argument syncsPerTick defines how often a clock synchronization should happen. Per default it synchronizes once per tick (i.e. an 1-increment of simulation time). It may happen that a simulation is too complex to run at a defined clock. In such a situation, it (i.e. Environment.run() ) will throw a ClockOverloadException if the user has specified a maximum delay maxDelay parameter between simulation and wall clock coordinates. Tick Transformation Simulation time is measured in ticks. Usually, a simulation starts at 0 and then progresses through actions such as hold or wait or component generation. To enable a more eye-friendly logging and to stay closer to the system under study, kalasim supports a built in transformation tickTransform to convert from simulation to wall clock. Let's consider the following example //TickTrafoExample.kts import org.kalasim.* import java.time.Duration import java.time.Instant import java.util.concurrent.TimeUnit createSimulation ( true ) { tickTransform = OffsetTransform ( Instant . now (), TimeUnit . MINUTES ) // run until a specific time run ( until = Instant . now (). plus ( Duration . ofHours ( 1 )). asTickTime ()) // run for a given duration run ( Duration . ofHours ( 1 ). asTicks ()) println ( asWallTime ( now )) } This example will run for 2h in total which is transformed to 2x60 ticks, and will report a transform wall time of now plus 120 minutes. It also illustrates the 3 supported provided transformations: asWallTime(tickTime) - Transforms a simulation time (typically now ) to the corresponding wall time. asTickDuration(duration) - Transforms a wall duration into the corresponding amount of ticks. asTickTime(instant) - Transforms an wall Instant to simulation time. Please note that setting this transformation does not impact the actual simulation, which is always carried out in ticks. It can be configured independently from the clock synchronization described above. There is one provided implementation OffsetTransform that can be instantiated with a start time offset the unit of a tick. The user can also implement own transformation by implementing the functional interface TickTransform . Operational Control Even if kalasim tries to provide a simplistic, efficient, declarative approach to define a simulation, it may come along with computational demands simulation. To allow introspection into time-complexity of the underlying computations, the user may want to use the built-in env.tickMetrics monitor to analyze how much time is spent per time unit (aka tick ). This monitor is not enabled by default and needs to be enabled when the environment is created by passing enableTickMetrics=true import org.kalasim.Component import org.kalasim.createSimulation import org.kalasim.plot.letsplot.display createSimulation ( enableTickMetrics = true ) { object : Component () { override fun process () = sequence { while ( true ) { // create some artificial non-linear compute load if ( now . value < 7 ) Thread . sleep (( now . value * 100 ). toLong ()) else { Thread . sleep ( 100 ) } hold ( 1 ) } } } run ( 10 ) tickMetrics . display (). show () } Performance tuning There are multiple ways to improve the performance of a simulation. Set the correct AssertMode : The assertion mode determines which internal consistency checks are being performed. The mode can be set to Full (Slowest), Light (default) or Off (Fastest). Depending on simulation logic and complexity, this will improve performance by ~20%. Disable internal event logging: The interaction model is configured by default to provide insights into the simulation via the event log . However, to optimize performance of a simulation a user may want to consume only custom event-types. If so, internal interaction logging can be disabled by setting logCoreInteractions = false when creating/configuring a component . Disable component statistics: Components and queues log various component statistics with built-in monitors which can be disabled to reduce compute and memory footprint of a simulation. To further fine-tune and optimize simulation performance and to reveal bottlenecks, a JVM profiler (such as yourkit ) can be used. Both call-counts and spent-time analysis have been proven useful here. Continuous Simulation For some use-cases, simulations may for a very long tick and wall time. To prevent internal metrics gathering from consuming all available memory, it needs to be disabled or at least configured carefully. This can be achieved, but either disabling timelines and monitors manually, or by setting a sensible default strategy using the env.trackingPolicyFactory // first define the policy and matcher env . trackingPolicyFactory . register ( ResourceTrackingConfig (). copy ( trackUtilization = false )) { it . name . startsWith ( \"Counter\" ) } // Second, we can create entities that will comply to the polices if being matched val r = Resource ( \"Counter 22\" ) For each entity type a corresponding TrackinConfig can be provisioned along with an entity matcher to narrow down its scope. Note Tracking configuration policies must be set before instantiating simulation entities to be used. After entities have been created, the user can still configure via c.trackingConfig . To disable all metrics and to minimize internal event logging, the user can run env.trackingPolicyFactory.disableAll() The same mechanism applies also fine-tune the internal event logging . By disabling some - not-needed for production - events, simulation performance can be improved significantly. The user can also register her own TrackConfig implementations using the factory. See here for simple example. Save and Load Simulations kalasim does not include a default mechanism to serialize and deserialize simulations yet. However, it seems that with xstream that Environment can be saved including its current simulation state across all included entities. It can be restored from the xml snapshot and continued with run() . We have not succeeded to do the same with gson yet. Also, some experiments with kotlinx.serialization were not that successful. Internal State Validation The simulation engine provides different levels of internal consistency checks. As these are partially computationally expensive these can be be/disabled. There are 3 modes OFF - Productive mode, where asserts that may impact performance are disabled. LIGHT - Disables compute-intensive asserts. This will have a minimal to moderate performance impact on simulations. FULL - Full introspection, this will have a measurable performance impact on simulations. E.g. it will validate that passive components are not scheduled, and queued components have unique names. Switching off asserts, will typically optimize performance by another ~20% (depending on simulation logic).","title":"Advanced"},{"location":"advanced/#clock-synchronization","text":"In simulation a clear distinction is made between real time and simulation time. With real time we refer to the wall-clock time. It represents the execution time of the experiment. The simulation time is an attribute of the simulator. To support use cases where a simulation may drive a demonstration or system check, the kalasim API allows to run a simulation at a defined clock speed. Such real-time simulations may be necessary If you have hardware-in-the-loop If the intent of the simulation is to drive a visualization of a process If there is human interaction with your simulation, or If you want to analyze the real-time behavior of an algorithm import org.kalasim.ClockSync import org.kalasim.createSimulation import java.time.Duration val timeBefore = System . currentTimeMillis () createSimulation ( true ) { // enable real-time clock synchronization w ClockSync ( tickDuration = Duration . ofSeconds ( 1 )) // enable real-time clock synchronization but run in 2x realtime // ClockSync(Duration.ofSeconds(1), speedUp = 2) run ( 10 ) } println ( \"time passed ${ System . currentTimeMillis () - timeBefore } )\" ) This example will execute in 10 seconds. Since the simulation is empty (for educational reasons to keep the focus on the clock here), it is entirely idle during that time. To enable clock synchronization, we need to add a ClockSync to our simulation. We need to define what one tick in simulation time corresponds to in wall time. In the example, one tick equals to one second wall time. This is configured with the parameter tickDuration . It defines the duration of a simulation tick in wall clock coordinates. It can be created with Duration.ofSeconds(1) , Duration.ofMinutes(10) and so on . ClockSync also provides settings for more advanced uses-cases To run simulations, in more than realtime, the user can specify speedUp to run a simulation faster ( speedUp > 1) or slower ( speedUp < 1) than realtime. It defaults to 1 , that is no speed-up will be applied. The argument syncsPerTick defines how often a clock synchronization should happen. Per default it synchronizes once per tick (i.e. an 1-increment of simulation time). It may happen that a simulation is too complex to run at a defined clock. In such a situation, it (i.e. Environment.run() ) will throw a ClockOverloadException if the user has specified a maximum delay maxDelay parameter between simulation and wall clock coordinates.","title":"Clock Synchronization"},{"location":"advanced/#tick-transformation","text":"Simulation time is measured in ticks. Usually, a simulation starts at 0 and then progresses through actions such as hold or wait or component generation. To enable a more eye-friendly logging and to stay closer to the system under study, kalasim supports a built in transformation tickTransform to convert from simulation to wall clock. Let's consider the following example //TickTrafoExample.kts import org.kalasim.* import java.time.Duration import java.time.Instant import java.util.concurrent.TimeUnit createSimulation ( true ) { tickTransform = OffsetTransform ( Instant . now (), TimeUnit . MINUTES ) // run until a specific time run ( until = Instant . now (). plus ( Duration . ofHours ( 1 )). asTickTime ()) // run for a given duration run ( Duration . ofHours ( 1 ). asTicks ()) println ( asWallTime ( now )) } This example will run for 2h in total which is transformed to 2x60 ticks, and will report a transform wall time of now plus 120 minutes. It also illustrates the 3 supported provided transformations: asWallTime(tickTime) - Transforms a simulation time (typically now ) to the corresponding wall time. asTickDuration(duration) - Transforms a wall duration into the corresponding amount of ticks. asTickTime(instant) - Transforms an wall Instant to simulation time. Please note that setting this transformation does not impact the actual simulation, which is always carried out in ticks. It can be configured independently from the clock synchronization described above. There is one provided implementation OffsetTransform that can be instantiated with a start time offset the unit of a tick. The user can also implement own transformation by implementing the functional interface TickTransform .","title":"Tick Transformation"},{"location":"advanced/#operational-control","text":"Even if kalasim tries to provide a simplistic, efficient, declarative approach to define a simulation, it may come along with computational demands simulation. To allow introspection into time-complexity of the underlying computations, the user may want to use the built-in env.tickMetrics monitor to analyze how much time is spent per time unit (aka tick ). This monitor is not enabled by default and needs to be enabled when the environment is created by passing enableTickMetrics=true import org.kalasim.Component import org.kalasim.createSimulation import org.kalasim.plot.letsplot.display createSimulation ( enableTickMetrics = true ) { object : Component () { override fun process () = sequence { while ( true ) { // create some artificial non-linear compute load if ( now . value < 7 ) Thread . sleep (( now . value * 100 ). toLong ()) else { Thread . sleep ( 100 ) } hold ( 1 ) } } } run ( 10 ) tickMetrics . display (). show () }","title":"Operational Control"},{"location":"advanced/#performance-tuning","text":"There are multiple ways to improve the performance of a simulation. Set the correct AssertMode : The assertion mode determines which internal consistency checks are being performed. The mode can be set to Full (Slowest), Light (default) or Off (Fastest). Depending on simulation logic and complexity, this will improve performance by ~20%. Disable internal event logging: The interaction model is configured by default to provide insights into the simulation via the event log . However, to optimize performance of a simulation a user may want to consume only custom event-types. If so, internal interaction logging can be disabled by setting logCoreInteractions = false when creating/configuring a component . Disable component statistics: Components and queues log various component statistics with built-in monitors which can be disabled to reduce compute and memory footprint of a simulation. To further fine-tune and optimize simulation performance and to reveal bottlenecks, a JVM profiler (such as yourkit ) can be used. Both call-counts and spent-time analysis have been proven useful here.","title":"Performance tuning"},{"location":"advanced/#continuous-simulation","text":"For some use-cases, simulations may for a very long tick and wall time. To prevent internal metrics gathering from consuming all available memory, it needs to be disabled or at least configured carefully. This can be achieved, but either disabling timelines and monitors manually, or by setting a sensible default strategy using the env.trackingPolicyFactory // first define the policy and matcher env . trackingPolicyFactory . register ( ResourceTrackingConfig (). copy ( trackUtilization = false )) { it . name . startsWith ( \"Counter\" ) } // Second, we can create entities that will comply to the polices if being matched val r = Resource ( \"Counter 22\" ) For each entity type a corresponding TrackinConfig can be provisioned along with an entity matcher to narrow down its scope. Note Tracking configuration policies must be set before instantiating simulation entities to be used. After entities have been created, the user can still configure via c.trackingConfig . To disable all metrics and to minimize internal event logging, the user can run env.trackingPolicyFactory.disableAll() The same mechanism applies also fine-tune the internal event logging . By disabling some - not-needed for production - events, simulation performance can be improved significantly. The user can also register her own TrackConfig implementations using the factory. See here for simple example.","title":"Continuous Simulation"},{"location":"advanced/#save-and-load-simulations","text":"kalasim does not include a default mechanism to serialize and deserialize simulations yet. However, it seems that with xstream that Environment can be saved including its current simulation state across all included entities. It can be restored from the xml snapshot and continued with run() . We have not succeeded to do the same with gson yet. Also, some experiments with kotlinx.serialization were not that successful.","title":"Save and Load Simulations"},{"location":"advanced/#internal-state-validation","text":"The simulation engine provides different levels of internal consistency checks. As these are partially computationally expensive these can be be/disabled. There are 3 modes OFF - Productive mode, where asserts that may impact performance are disabled. LIGHT - Disables compute-intensive asserts. This will have a minimal to moderate performance impact on simulations. FULL - Full introspection, this will have a measurable performance impact on simulations. E.g. it will validate that passive components are not scheduled, and queued components have unique names. Switching off asserts, will typically optimize performance by another ~20% (depending on simulation logic).","title":"Internal State Validation"},{"location":"analysis/","text":"Analysis A core aspect when building simulations is to understand, define and modulate the inherent system dynamics. To build a correct simulation, the designer/developer must carefully analyze how states progress over time. To facilitate this process, kalasim offers various means to analyze data created by a simulation The Event Log tracks events in a simulation Monitors track state and statistics of the basic elements within a simulation, and may be used for domain-specific entities as well Lifecycle Records summarize a component's states history visualization to inspect complex spatio-temporal patterns Monitors See chapter about monitors . Event Log See chapter about event logging . Visualization See chapter about visualization . Component Status The state transition of a component provide value insight into its behavior. This is facilitated by lifecycle statistics ComponentLifecycleRecord that summarize a component's states history. These data can also be transformed easily into a table as well val customers : List < Component > // = ... val records : List < ComponentLifecycleRecord > = customers . map { it . toLifeCycleRecord () } records . asDataFrame () This transforms the customers straight into a krangl dataframe with the following structure A DataFrame: 1034 x 11 component createdAt inCurrent inData inDataSince inInterrupted inPassive 1 Vehicle.1 0.366 0 989.724 10.276 0 0 2 Vehicle.2 1.294 0 984.423 15.577 0 0 3 Vehicle.3 1.626 0 989.724 10.276 0 0 4 Vehicle.4 2.794 0 989.724 10.276 0 0 and 1024 more rows, and and 4 more variables: inScheduled, inStandby, inWaiting Clearly if needed, the user may also work with the records directly. For instance to configure a visualization. Replication Running a simulation just once, often does not provide sufficient insights into the dynamics of the system under consideration. Often, the user may want to execute a model many times with altered initial conditions, and then perform a statistical analysis over the output. This is also considered as what-if analyis. See here for simple example. By design kalasim does not make use of parallelism. So when scaling up execution to run in paralell, we need to be careful, that the internal dependency injection (which relates by default to a global context variable) does not cause trouble. See here for an example that defines a parameter grid to be assessed with multi-threading with a simulation run per hyper-parameter. Component Tracking To prevent memory leaks, the environment just keeps track of scheduled components, that is components that are queued for execution. In some situations the user may want to track all components irrespective of their queuing status. This can be achieved by setting up a component collector before creating the components createSimulation { val cc = componentCollector () // create components Component ( \"foo\" ) Component ( \"bar\" ) // analyze all components created until this point cc . size // will be 2 }","title":"Analysis"},{"location":"analysis/#analysis","text":"A core aspect when building simulations is to understand, define and modulate the inherent system dynamics. To build a correct simulation, the designer/developer must carefully analyze how states progress over time. To facilitate this process, kalasim offers various means to analyze data created by a simulation The Event Log tracks events in a simulation Monitors track state and statistics of the basic elements within a simulation, and may be used for domain-specific entities as well Lifecycle Records summarize a component's states history visualization to inspect complex spatio-temporal patterns","title":"Analysis"},{"location":"analysis/#monitors","text":"See chapter about monitors .","title":"Monitors"},{"location":"analysis/#event-log","text":"See chapter about event logging .","title":"Event Log"},{"location":"analysis/#visualization","text":"See chapter about visualization .","title":"Visualization"},{"location":"analysis/#component-status","text":"The state transition of a component provide value insight into its behavior. This is facilitated by lifecycle statistics ComponentLifecycleRecord that summarize a component's states history. These data can also be transformed easily into a table as well val customers : List < Component > // = ... val records : List < ComponentLifecycleRecord > = customers . map { it . toLifeCycleRecord () } records . asDataFrame () This transforms the customers straight into a krangl dataframe with the following structure A DataFrame: 1034 x 11 component createdAt inCurrent inData inDataSince inInterrupted inPassive 1 Vehicle.1 0.366 0 989.724 10.276 0 0 2 Vehicle.2 1.294 0 984.423 15.577 0 0 3 Vehicle.3 1.626 0 989.724 10.276 0 0 4 Vehicle.4 2.794 0 989.724 10.276 0 0 and 1024 more rows, and and 4 more variables: inScheduled, inStandby, inWaiting Clearly if needed, the user may also work with the records directly. For instance to configure a visualization.","title":"Component Status"},{"location":"analysis/#replication","text":"Running a simulation just once, often does not provide sufficient insights into the dynamics of the system under consideration. Often, the user may want to execute a model many times with altered initial conditions, and then perform a statistical analysis over the output. This is also considered as what-if analyis. See here for simple example. By design kalasim does not make use of parallelism. So when scaling up execution to run in paralell, we need to be careful, that the internal dependency injection (which relates by default to a global context variable) does not cause trouble. See here for an example that defines a parameter grid to be assessed with multi-threading with a simulation run per hyper-parameter.","title":"Replication"},{"location":"analysis/#component-tracking","text":"To prevent memory leaks, the environment just keeps track of scheduled components, that is components that are queued for execution. In some situations the user may want to track all components irrespective of their queuing status. This can be achieved by setting up a component collector before creating the components createSimulation { val cc = componentCollector () // create components Component ( \"foo\" ) Component ( \"bar\" ) // analyze all components created until this point cc . size // will be 2 }","title":"Component Tracking"},{"location":"basics/","text":"The beauty of discrete event simulation is its very limited vocabulary which still allow expressing complex system dynamics. In essence, kalasim relies on just a handful of elements to model real-world processes. Components Resources States Collections Generators Simulation Environment All entities in a simulation are governed by a environment context. Every simulation lives in exactly one such environment. The environment provides means for controlled randomization , dependency injection , and most importantly manages the event queue . The environment context of a kalasim simulation is an instance of org.kalasim.Environment , which can be created using simple instantiation or via a builder called createSimulation val env : Environment = createSimulation ( enableConsoleLogger = true ){ // Create simulation entities in here Car () Resource ( \"Car Wash\" ) }. run ( 5.0 ) Within its environment, a simulation contains one or multiple components with process definition s that define their behavior and interplay with other simulation entities. Very often, the user will define custom Environments to streamline simulation API experience. class MySim ( val numCustomers : Int = 5 ) : Environment (){ val customers = List ( numCustomers ){ Customer ( it ) } } val sim = MySim ( 10 ) sim . run () // analyze customers sim . customers . first (). statusTimeline . display () To configure references first, an Environment can also be instantiated by configuring dependencies first with configureEnvironment . Check out the Traffic example to learn how that works. Running a simulation In a discrete event simulation a clear distinction is made between real time and simulation time. With real time we refer to the wall-clock time. It represents the execution time of the experiment. The simulation time is an attribute of the simulator. Tip The user can define a transformation to map the internal clock to her wall-time clock As shown in the example from above a simulation is usually started with sim.run(ticks) . Here ticks is the number of ticks, that is simulation time units. The simulation will progress for ticks . By doing so we may stop right in the middle of a process . Alternatively, we can also run until the event queue is empty (or forever depending on the model) by omitting the argument: sim . run ( 23 ) // run for 23 ticks sim . run ( 5 ) // run for some more ticks sim . run ( until = 42. tickTime ) // run until internal simulation clock is 23 sim . run () // run until event queue is empty Tip A component can always stop the current simulation by calling stopSimulation() in its process definition . See here for fully worked out example. Event Queue The core of kalasim is an event queue ordered by scheduled execution time, that maintains a list of events to be executed. To provide good insert, delete and update performance, kalasim is using a PriorityQueue internally. Components are actively and passively scheduled for reevaluating their state. Technically, event execution refers to the continuation of a component's process definition . Kalasim Execution Model Execution Order In the real world, events often appear to happen at the same time . However, in fact events always occur at slightly differing times. Clearly the notion of same depends on the resolution of the used time axis. Birthdays will happen on the same day whereas the precise birth events will always differ in absolute timing. Even if real-world processes may run \"in parallel\", a simulation is processed sequentially and deterministically. With the same random-generator initialization, you will always get the same simulation results when running your simulation multiple times. Although, kalasim supports double-precision to schedule events, events will inevitably arise that are scheduled for the same time . Because of its single-threaded, deterministic execution model (like most DES frameworks), kalasim processes events sequentially \u2013 one after another. If two events are scheduled at the same time, the one scheduled first will also be the processed first (FIFO). As pointed out in Ucar, 2019 , there are many situations where simultaneous events may occur in simulation. To provide a well-defined behavior in such situations, process interaction methods (namely wait , request , activate and reschedule ) support user-define [schedule priorities]. With the parameter priority , it is possible to sort a component before or after other components, scheduled for the same time. Events with higher priority are executed first in situations where multiple events are scheduled for the same simulation time. There are different predefined priorities which correspond the following sort-levels LOWEST (-20) LOW (-10) NORMAL (0) IMPORTANT (20) CRITICAL (20) The user can also create more fine-grained priorities with Priority(23) In contrast to other DSE implementations, the user does not need to make sure that a resource release() is prioritized over a simultaneous request() . The engine will automatically reschedule tasks accordingly. So the key points to recall are Real world events may appear to happen at the same discretized simulation time Simulation events are processed one after another, even if they are scheduled for the same time Race-conditions between events can be avoided by setting a priority Dependency Injection Kalasim is building on top of koin to inject dependencies between elements of a simulation. This allows creating simulation entities such as resources, components or states conveniently without passing around references. class Car : Component () { val gasStation by inject < GasStation > () override fun process () = sequence { request ( gasStation ) { hold ( 2 , \"refill\" ) } val trafficLight = get < TrafficLight > () wait ( trafficLight , \"green\" ) } } createSimulation { dependency { TrafficLight () } dependency { GasStation () } Car () } As shown in the example, the user can simply pull dependencies from the simulation environment using get<T>() or inject<T>() . This is realized with via Koin Context Isolation provided by a thread-local DependencyContext . This context is a of type KalasimContext . It is automatically created when calling createSimulation or by instantiating a new simulation Environment . This context is kept as a static reference, so the user may omit it when creating simulation entities. Typically, dependency context management is fully transparent to the user. Environment (). apply { // implicit context provisioning (recommended) val inUse = State ( true ) // explicit context provisioning val inUse2 = State ( true , koin = getKoin ()) } In the latter case, the context reference is provided explicitly. This is usually not needed nor recommended. Threadsafe Registry Because of its thread locality awareness, the dependency resolver of kalasim allows for parallel simulations. That means, that even when running multiple simulations in parallel in different threads, the user does not have to provide a dependency context (called koin ) argument when creating new simulation entities (such as components ). For a simulation example with multiple parallel Environment s see ATM Queue Simple Types Koin does not allow injecting simple types. To inject simple variables, consider using a wrapper class. Example ////SimpleInject.kts import org.kalasim.Component import org.kalasim.add import org.kalasim.configureEnvironment data class Counter ( var value : Int ) class Something ( val counter : Counter ) : Component () { override fun process () = sequence < Component > { counter . value ++ } } configureEnvironment { add { Counter ( 0 ) } add { Something ( get ()) } }. run ( 10 ) For details about how to use lazy injection with inject<T>() and instance retrieval with get<T>() see koin reference . Examples Traffic Car Wash Gas Station Randomness & Distributions Experimentation in a simulation context relates to large part to controlling randomness. Here, this is achieved by using probabilistic distributions which are internally backed by apache-commons-math . A simulation always allows deterministic execution while still supporting pseudo-random sampling. When creating a new simulation environment , the user can provide a random seed which is internally resolved to a random generator to be used in process definitions. createSimulation ( randomSeed = 123 ){ val randomGenerator = rg // which is resolved by Environment receiver } With random generator, the following number distributions are supported out of the box (with common defaults where possible) as extension functions on Component and Environment : uniform(lower=0, upper=1) discreteUniform(lower, upper) exponential(mean) normal(mean=0, sd=1) Whenever, distributions are needed in method signatures in kalasim , the more general interface org.apache.commons.math3.distribution.RealDistribution is being used to support a much wider variety of distributions if needed. So we can also use other implementations as well. For example ComponentGenerator ( iat = NakagamiDistribution ( 1 , 0.3 )){ Customer () } The API also include some convenience wrappers to provide fixed values for argument of RealDistribution . E.g. consider the time until a request is considered as failed: val dist = constant ( 3 ) ComponentGenerator ( iat = dist ){ Customer () } Here, 3 is converted into a org.apache.commons.math3.distribution.ConstantRealDistribution . Also, RealDistribution.clip(0) will cap the sampled values at 0 (or any other value, allowing zero-inflated distribution models with controlled randomization !!important All distribution helpers to allow controlled randomization are available only form an Environment or SimulationContext only. That's because kalasim needs the context to associate the correct internal random generator to each distribution. Similarly, also distributions over arbitrary types are supported via enumerated . This does not just work with enums but with arbitrary types including data classes . enum class Fruit { Apple , Banana , Peach } // create a uniform distribution over the fruits val fruit = enumerated ( values ()) // sample the fruits val aFruit : Fruit = fruit () // create a uniform distribution over the fruits val biasedFruit = enumerated ( Apple to 0.7 , Banana to 0.1 , Peach to 0.2 ) // sample the biased fruits biasedFruit () Controlled randomization is a key aspect of every process simulation. Make sure to always strive for repeatability by not using randomization outside of what the simulation context provides.","title":"Simulation Basics"},{"location":"basics/#simulation-environment","text":"All entities in a simulation are governed by a environment context. Every simulation lives in exactly one such environment. The environment provides means for controlled randomization , dependency injection , and most importantly manages the event queue . The environment context of a kalasim simulation is an instance of org.kalasim.Environment , which can be created using simple instantiation or via a builder called createSimulation val env : Environment = createSimulation ( enableConsoleLogger = true ){ // Create simulation entities in here Car () Resource ( \"Car Wash\" ) }. run ( 5.0 ) Within its environment, a simulation contains one or multiple components with process definition s that define their behavior and interplay with other simulation entities. Very often, the user will define custom Environments to streamline simulation API experience. class MySim ( val numCustomers : Int = 5 ) : Environment (){ val customers = List ( numCustomers ){ Customer ( it ) } } val sim = MySim ( 10 ) sim . run () // analyze customers sim . customers . first (). statusTimeline . display () To configure references first, an Environment can also be instantiated by configuring dependencies first with configureEnvironment . Check out the Traffic example to learn how that works.","title":"Simulation Environment"},{"location":"basics/#running-a-simulation","text":"In a discrete event simulation a clear distinction is made between real time and simulation time. With real time we refer to the wall-clock time. It represents the execution time of the experiment. The simulation time is an attribute of the simulator. Tip The user can define a transformation to map the internal clock to her wall-time clock As shown in the example from above a simulation is usually started with sim.run(ticks) . Here ticks is the number of ticks, that is simulation time units. The simulation will progress for ticks . By doing so we may stop right in the middle of a process . Alternatively, we can also run until the event queue is empty (or forever depending on the model) by omitting the argument: sim . run ( 23 ) // run for 23 ticks sim . run ( 5 ) // run for some more ticks sim . run ( until = 42. tickTime ) // run until internal simulation clock is 23 sim . run () // run until event queue is empty Tip A component can always stop the current simulation by calling stopSimulation() in its process definition . See here for fully worked out example.","title":"Running a simulation"},{"location":"basics/#event-queue","text":"The core of kalasim is an event queue ordered by scheduled execution time, that maintains a list of events to be executed. To provide good insert, delete and update performance, kalasim is using a PriorityQueue internally. Components are actively and passively scheduled for reevaluating their state. Technically, event execution refers to the continuation of a component's process definition . Kalasim Execution Model","title":"Event Queue"},{"location":"basics/#execution-order","text":"In the real world, events often appear to happen at the same time . However, in fact events always occur at slightly differing times. Clearly the notion of same depends on the resolution of the used time axis. Birthdays will happen on the same day whereas the precise birth events will always differ in absolute timing. Even if real-world processes may run \"in parallel\", a simulation is processed sequentially and deterministically. With the same random-generator initialization, you will always get the same simulation results when running your simulation multiple times. Although, kalasim supports double-precision to schedule events, events will inevitably arise that are scheduled for the same time . Because of its single-threaded, deterministic execution model (like most DES frameworks), kalasim processes events sequentially \u2013 one after another. If two events are scheduled at the same time, the one scheduled first will also be the processed first (FIFO). As pointed out in Ucar, 2019 , there are many situations where simultaneous events may occur in simulation. To provide a well-defined behavior in such situations, process interaction methods (namely wait , request , activate and reschedule ) support user-define [schedule priorities]. With the parameter priority , it is possible to sort a component before or after other components, scheduled for the same time. Events with higher priority are executed first in situations where multiple events are scheduled for the same simulation time. There are different predefined priorities which correspond the following sort-levels LOWEST (-20) LOW (-10) NORMAL (0) IMPORTANT (20) CRITICAL (20) The user can also create more fine-grained priorities with Priority(23) In contrast to other DSE implementations, the user does not need to make sure that a resource release() is prioritized over a simultaneous request() . The engine will automatically reschedule tasks accordingly. So the key points to recall are Real world events may appear to happen at the same discretized simulation time Simulation events are processed one after another, even if they are scheduled for the same time Race-conditions between events can be avoided by setting a priority","title":"Execution Order"},{"location":"basics/#dependency-injection","text":"Kalasim is building on top of koin to inject dependencies between elements of a simulation. This allows creating simulation entities such as resources, components or states conveniently without passing around references. class Car : Component () { val gasStation by inject < GasStation > () override fun process () = sequence { request ( gasStation ) { hold ( 2 , \"refill\" ) } val trafficLight = get < TrafficLight > () wait ( trafficLight , \"green\" ) } } createSimulation { dependency { TrafficLight () } dependency { GasStation () } Car () } As shown in the example, the user can simply pull dependencies from the simulation environment using get<T>() or inject<T>() . This is realized with via Koin Context Isolation provided by a thread-local DependencyContext . This context is a of type KalasimContext . It is automatically created when calling createSimulation or by instantiating a new simulation Environment . This context is kept as a static reference, so the user may omit it when creating simulation entities. Typically, dependency context management is fully transparent to the user. Environment (). apply { // implicit context provisioning (recommended) val inUse = State ( true ) // explicit context provisioning val inUse2 = State ( true , koin = getKoin ()) } In the latter case, the context reference is provided explicitly. This is usually not needed nor recommended.","title":"Dependency Injection"},{"location":"basics/#threadsafe-registry","text":"Because of its thread locality awareness, the dependency resolver of kalasim allows for parallel simulations. That means, that even when running multiple simulations in parallel in different threads, the user does not have to provide a dependency context (called koin ) argument when creating new simulation entities (such as components ). For a simulation example with multiple parallel Environment s see ATM Queue","title":"Threadsafe Registry"},{"location":"basics/#simple-types","text":"Koin does not allow injecting simple types. To inject simple variables, consider using a wrapper class. Example ////SimpleInject.kts import org.kalasim.Component import org.kalasim.add import org.kalasim.configureEnvironment data class Counter ( var value : Int ) class Something ( val counter : Counter ) : Component () { override fun process () = sequence < Component > { counter . value ++ } } configureEnvironment { add { Counter ( 0 ) } add { Something ( get ()) } }. run ( 10 ) For details about how to use lazy injection with inject<T>() and instance retrieval with get<T>() see koin reference . Examples Traffic Car Wash Gas Station","title":"Simple Types"},{"location":"basics/#randomness-distributions","text":"Experimentation in a simulation context relates to large part to controlling randomness. Here, this is achieved by using probabilistic distributions which are internally backed by apache-commons-math . A simulation always allows deterministic execution while still supporting pseudo-random sampling. When creating a new simulation environment , the user can provide a random seed which is internally resolved to a random generator to be used in process definitions. createSimulation ( randomSeed = 123 ){ val randomGenerator = rg // which is resolved by Environment receiver } With random generator, the following number distributions are supported out of the box (with common defaults where possible) as extension functions on Component and Environment : uniform(lower=0, upper=1) discreteUniform(lower, upper) exponential(mean) normal(mean=0, sd=1) Whenever, distributions are needed in method signatures in kalasim , the more general interface org.apache.commons.math3.distribution.RealDistribution is being used to support a much wider variety of distributions if needed. So we can also use other implementations as well. For example ComponentGenerator ( iat = NakagamiDistribution ( 1 , 0.3 )){ Customer () } The API also include some convenience wrappers to provide fixed values for argument of RealDistribution . E.g. consider the time until a request is considered as failed: val dist = constant ( 3 ) ComponentGenerator ( iat = dist ){ Customer () } Here, 3 is converted into a org.apache.commons.math3.distribution.ConstantRealDistribution . Also, RealDistribution.clip(0) will cap the sampled values at 0 (or any other value, allowing zero-inflated distribution models with controlled randomization !!important All distribution helpers to allow controlled randomization are available only form an Environment or SimulationContext only. That's because kalasim needs the context to associate the correct internal random generator to each distribution. Similarly, also distributions over arbitrary types are supported via enumerated . This does not just work with enums but with arbitrary types including data classes . enum class Fruit { Apple , Banana , Peach } // create a uniform distribution over the fruits val fruit = enumerated ( values ()) // sample the fruits val aFruit : Fruit = fruit () // create a uniform distribution over the fruits val biasedFruit = enumerated ( Apple to 0.7 , Banana to 0.1 , Peach to 0.2 ) // sample the biased fruits biasedFruit () Controlled randomization is a key aspect of every process simulation. Make sure to always strive for repeatability by not using randomization outside of what the simulation context provides.","title":"Randomness &amp; Distributions"},{"location":"changes/","text":"Kalasim Release History v0.8-SNAPSHOT Not yet released Added RequestScopeContext to honor-block of request including requestingSince time (relates to #27 ) #35 Improved support for asynchronous event consumption (contributed by pambrose via PR) Minor enhancements * Reworked distribution support API for better API experience to enable controlled randomization in process models * #38 Better API support for depletable resources v0.7 Released 2021-11-27 See release announcement Major enhancements Reworked event & metrics logging API Introduced ComponentList Implemented ticks metrics monitor (fixes #9 ) New timeline and activity log attributes to resources for streamlined usage and capacity analysis Extended display() support API on all major components and their collections (including Resource , Component or List<Component> , MetricTimeline ) (fixes #18 ) Thread-local context registry enabled via Koin Context Isolation (fixes #20 ) Dramatically improved simulation performance Documentation New chapter about collections Revised resource documentation Rewritten ATM example to better illustrate parallelization and generators New example Bridge Games Started new canonical complex simulation example: emergency room Minor enhancements Added possibility stop a simulation from a process definition using `stopSimulation Introduced AssertMode s ( Full , Light (default), None ) to enable/disable internal consistency checks . This will optimize performance by another ~20% (depending on simulation logic) Improved request priority API Allow for runtime reconfiguration of ClockSync to enable adjustable simulation speed Lifted Component sub-type requirement from ComponentQueue Fixed oneOf in request() Redesigned honorBlock in request() to return Unit and to provide claimed resource via it request ( doctorFoo , doctorBar , oneOf = true ) { doctor -> println ( \"patient treated by $ doctor \" ) } Added RealDistribution.clip to allow zero-inflated distribution models with controlled randomization Breaking changes Removed components from Environment and created componentCollector as optional replacement Redesigned events & metrics API Updated to koin v3.1 (fixes #15 ): GlobalContext has been replaced with DependencyContext Established use of TickTime across the entire API to disambiguate simulation time instants from durations, which are still modelled as Double Changed Component.now and Environment.now to new value class TickTime for better type safety Simplified ClockSync API by removing redundant speedUp parameter Component.status has been renamed to Component.componentState to enable extending classes to use the property name status for domain modelling Removed requirement to implement info in SimulationEntity Moved stochastic distributions support API to from Component to SimulationEntity Removed Component::setup because the user can just use an init{} block instead Migrated release channel from jcenter to maven-central v0.6 Released 2021-02-12 -> Updated to v0.6.6 on 2021-05-05 Major Enhancements Added selectResource() to select from resources with policy val doctors = List ( 3 ) { Resource () } val selected = selectResource ( doctors , policy = SHORTEST_QUEUE ) New suspending batch interaction to group an entity stream into blocks val queue = ComponentQueue < Customer > () val batchLR : List < Customer > = batch ( queue , 4 , timeout = 10 ) Added option to configure a tick to wall time transformer createSimulation { tickTransform = OffsetTransform ( Instant . now (), TimeUnit . MINUTES ) run ( Duration . ofMinutes ( 90 ). asTicks ()) println ( asWallTime ( now )) } Added lifecycle records to streamline component state analyses Changed ComponentGenerator to allow generating arbitrary types (and not just Component s) ComponentGenerator ( uniform ( 0 , 1 )){ counter -> \"smthg no ${ counter } \" } Added forceStart to ComponentGenerator to define if an arrival should be happen when it is activated for the first time Changed scheduling priority from Int to inline class Priority (with defaults NORMAL , HIGH , LOW ) in all interaction methods for more typesafe API Started bundled simulations for adhoc experimentation and demonstration by adding M/M/1 queue MM1Queue Added support for pluggable visualization backend. Currently kravis and lets-plot are supported. For jupyter-notebook examples mm1-queue analysis // simply toggle backend by package import import org.kalasim.plot.letsplot.display // or //import org.kalasim.plot.kravis.display MM1Queue (). apply { run ( 100 ) server . claimedMonitor . display () } New Example: \"The ferryman\" New Example: Office Tower v0.5 Released 2021-01-12 Major Enhancements Added first jupyter notebook example New depletable resource type New statistical distributions API New more structured event logging. See user manual Implemented support for real-time simulations New example Dining Philosophers New example Movie Theater New API to add dependencies in simulation context using dependency {} Notable Fixes Fixed failAt in request v0.4 Released 2021-01-03 Major Enhancements Implemented interrupt interaction Reworked documentation and examples Implemented standby Implement disable/enable for monitors Yield internally, to simplify process definitions // before object : Component () { override fun process () = sequence { yield ( hold ( 1.0 )) } } // now object : Component () { override fun process () = sequence { hold ( 1.0 ) } } Made scheduledTime nullable: Replaced scheduledTime = Double.MAX_VALUE with null where possible to provide better mental execution model Provide lambda parameter to enable auto-releasing of resources // before object : Component () { override fun process () = sequence { request ( r ) hold ( 1 ) release ( r ) } } // now object : Component () { override fun process () = sequence { request ( r ){ hold ( 1 ) } } } Implemented Environment.toString to provide json description Various bug-fixes v0.3 Reimplemented monitors Continued salabim core API reimplementation Fixed: Decouple simulation with different koin application contxts v0.2 Reimplement core salabim examples in kotlin Port all salabim examples Started MkDocs manual v0.1 Reimplement salabim's main component lifecycle Add timing API","title":"What's New?"},{"location":"changes/#kalasim-release-history","text":"","title":"Kalasim Release History"},{"location":"changes/#v08-snapshot","text":"Not yet released Added RequestScopeContext to honor-block of request including requestingSince time (relates to #27 ) #35 Improved support for asynchronous event consumption (contributed by pambrose via PR) Minor enhancements * Reworked distribution support API for better API experience to enable controlled randomization in process models * #38 Better API support for depletable resources","title":"v0.8-SNAPSHOT"},{"location":"changes/#v07","text":"Released 2021-11-27 See release announcement Major enhancements Reworked event & metrics logging API Introduced ComponentList Implemented ticks metrics monitor (fixes #9 ) New timeline and activity log attributes to resources for streamlined usage and capacity analysis Extended display() support API on all major components and their collections (including Resource , Component or List<Component> , MetricTimeline ) (fixes #18 ) Thread-local context registry enabled via Koin Context Isolation (fixes #20 ) Dramatically improved simulation performance Documentation New chapter about collections Revised resource documentation Rewritten ATM example to better illustrate parallelization and generators New example Bridge Games Started new canonical complex simulation example: emergency room Minor enhancements Added possibility stop a simulation from a process definition using `stopSimulation Introduced AssertMode s ( Full , Light (default), None ) to enable/disable internal consistency checks . This will optimize performance by another ~20% (depending on simulation logic) Improved request priority API Allow for runtime reconfiguration of ClockSync to enable adjustable simulation speed Lifted Component sub-type requirement from ComponentQueue Fixed oneOf in request() Redesigned honorBlock in request() to return Unit and to provide claimed resource via it request ( doctorFoo , doctorBar , oneOf = true ) { doctor -> println ( \"patient treated by $ doctor \" ) } Added RealDistribution.clip to allow zero-inflated distribution models with controlled randomization Breaking changes Removed components from Environment and created componentCollector as optional replacement Redesigned events & metrics API Updated to koin v3.1 (fixes #15 ): GlobalContext has been replaced with DependencyContext Established use of TickTime across the entire API to disambiguate simulation time instants from durations, which are still modelled as Double Changed Component.now and Environment.now to new value class TickTime for better type safety Simplified ClockSync API by removing redundant speedUp parameter Component.status has been renamed to Component.componentState to enable extending classes to use the property name status for domain modelling Removed requirement to implement info in SimulationEntity Moved stochastic distributions support API to from Component to SimulationEntity Removed Component::setup because the user can just use an init{} block instead Migrated release channel from jcenter to maven-central","title":"v0.7"},{"location":"changes/#v06","text":"Released 2021-02-12 -> Updated to v0.6.6 on 2021-05-05 Major Enhancements Added selectResource() to select from resources with policy val doctors = List ( 3 ) { Resource () } val selected = selectResource ( doctors , policy = SHORTEST_QUEUE ) New suspending batch interaction to group an entity stream into blocks val queue = ComponentQueue < Customer > () val batchLR : List < Customer > = batch ( queue , 4 , timeout = 10 ) Added option to configure a tick to wall time transformer createSimulation { tickTransform = OffsetTransform ( Instant . now (), TimeUnit . MINUTES ) run ( Duration . ofMinutes ( 90 ). asTicks ()) println ( asWallTime ( now )) } Added lifecycle records to streamline component state analyses Changed ComponentGenerator to allow generating arbitrary types (and not just Component s) ComponentGenerator ( uniform ( 0 , 1 )){ counter -> \"smthg no ${ counter } \" } Added forceStart to ComponentGenerator to define if an arrival should be happen when it is activated for the first time Changed scheduling priority from Int to inline class Priority (with defaults NORMAL , HIGH , LOW ) in all interaction methods for more typesafe API Started bundled simulations for adhoc experimentation and demonstration by adding M/M/1 queue MM1Queue Added support for pluggable visualization backend. Currently kravis and lets-plot are supported. For jupyter-notebook examples mm1-queue analysis // simply toggle backend by package import import org.kalasim.plot.letsplot.display // or //import org.kalasim.plot.kravis.display MM1Queue (). apply { run ( 100 ) server . claimedMonitor . display () } New Example: \"The ferryman\" New Example: Office Tower","title":"v0.6"},{"location":"changes/#v05","text":"Released 2021-01-12 Major Enhancements Added first jupyter notebook example New depletable resource type New statistical distributions API New more structured event logging. See user manual Implemented support for real-time simulations New example Dining Philosophers New example Movie Theater New API to add dependencies in simulation context using dependency {} Notable Fixes Fixed failAt in request","title":"v0.5"},{"location":"changes/#v04","text":"Released 2021-01-03 Major Enhancements Implemented interrupt interaction Reworked documentation and examples Implemented standby Implement disable/enable for monitors Yield internally, to simplify process definitions // before object : Component () { override fun process () = sequence { yield ( hold ( 1.0 )) } } // now object : Component () { override fun process () = sequence { hold ( 1.0 ) } } Made scheduledTime nullable: Replaced scheduledTime = Double.MAX_VALUE with null where possible to provide better mental execution model Provide lambda parameter to enable auto-releasing of resources // before object : Component () { override fun process () = sequence { request ( r ) hold ( 1 ) release ( r ) } } // now object : Component () { override fun process () = sequence { request ( r ){ hold ( 1 ) } } } Implemented Environment.toString to provide json description Various bug-fixes","title":"v0.4"},{"location":"changes/#v03","text":"Reimplemented monitors Continued salabim core API reimplementation Fixed: Decouple simulation with different koin application contxts","title":"v0.3"},{"location":"changes/#v02","text":"Reimplement core salabim examples in kotlin Port all salabim examples Started MkDocs manual","title":"v0.2"},{"location":"changes/#v01","text":"Reimplement salabim's main component lifecycle Add timing API","title":"v0.1"},{"location":"collections/","text":"Collections A very common element of discrete simulation models, are queues of elements that are consumed by downstream components. A basic example would be the waiting line in a bank . Clearly, the JVM and Kotlin provide a very rich collection API ecosystem. However, kalasim is providing its own implementations for List and Queue with ComponentList and ComponentQueue respectively, that are backed with standard implementation but add additional metrics and tracking to allow statistical analysis. If such functionality is not needed in a particular simulation model, standard collection implementation can be used as well without any restriction. Queue kalasim provides an instrumented queue implementation ComponentQueue on top of the JVM's PriorityQueue to model waiting lines etc. Conceptual our implementation is very similar to salabim 's queue . A typical use case would be a generator process (material, customers, etc.) that is consumed by other components. By definition, a generator is a Component that contains at least one yield in its process definition. In the following example a generator is creating new Customer s which are entering a waiting line Queue . This queue is consumed by a clerk which take one customer at a time and goes on hold for processing. See here for the complete implementation. sequenceDiagram EventLoop->>CustomerGenerator: Continue generator process CustomerGenerator->>Customer: Create new Customer CustomerGenerator-->>EventLoop: Reschedule for later Customer->>Queue: Enter waiting line Clerk->>Queue: Pull next customer Clerk-->>EventLoop: hold vor n time units for processing Examples ATM Queue Comparator By default, the ComponentQueue is sorted by priority and enter-time. To provide a custom ordering scheme, the user can supply her own comparator easily val cq = ComponentQueue ( comparator = compareBy < Patient > { it . severity }) // or using a chained comparator val cq2 = ComponentQueue ( comparator = compareBy < Patient > { it . severity }. thenBy { it . type }) Batching Queues can be consumed in a batched manner using the batch() . See \"The Ferryman\" for a worked out example and its API documentation. List As alternative to the ordered queue, kalasim also provides a similarly instrumented list implementation with ComponentList . It's only providing very basic FiFo queue characteristics with poll() supported by its backend. The main intent for ComponentList are more sophisticated use-cases that can not be modelled with a single queue. Examples are Machine scheduling with more than instance Service models with different In such cases, a simple Comparator (even a chained one) are often insufficient to model the complex scheduling requirements. Metrics Both, the ComponentList and the ComponentQueue provide a similar set of built-in metrics Monitors queueLengthMonitor tracks the queue length level across time lengthOfStayMonitor tracks the length of stay in the queue over time Statistics stats - Current state snapshot of queue statistics regarding length and length of stay info - Json-structured summary of the list/queue","title":"Collections"},{"location":"collections/#collections","text":"A very common element of discrete simulation models, are queues of elements that are consumed by downstream components. A basic example would be the waiting line in a bank . Clearly, the JVM and Kotlin provide a very rich collection API ecosystem. However, kalasim is providing its own implementations for List and Queue with ComponentList and ComponentQueue respectively, that are backed with standard implementation but add additional metrics and tracking to allow statistical analysis. If such functionality is not needed in a particular simulation model, standard collection implementation can be used as well without any restriction.","title":"Collections"},{"location":"collections/#queue","text":"kalasim provides an instrumented queue implementation ComponentQueue on top of the JVM's PriorityQueue to model waiting lines etc. Conceptual our implementation is very similar to salabim 's queue . A typical use case would be a generator process (material, customers, etc.) that is consumed by other components. By definition, a generator is a Component that contains at least one yield in its process definition. In the following example a generator is creating new Customer s which are entering a waiting line Queue . This queue is consumed by a clerk which take one customer at a time and goes on hold for processing. See here for the complete implementation. sequenceDiagram EventLoop->>CustomerGenerator: Continue generator process CustomerGenerator->>Customer: Create new Customer CustomerGenerator-->>EventLoop: Reschedule for later Customer->>Queue: Enter waiting line Clerk->>Queue: Pull next customer Clerk-->>EventLoop: hold vor n time units for processing Examples ATM Queue","title":"Queue"},{"location":"collections/#comparator","text":"By default, the ComponentQueue is sorted by priority and enter-time. To provide a custom ordering scheme, the user can supply her own comparator easily val cq = ComponentQueue ( comparator = compareBy < Patient > { it . severity }) // or using a chained comparator val cq2 = ComponentQueue ( comparator = compareBy < Patient > { it . severity }. thenBy { it . type })","title":"Comparator"},{"location":"collections/#batching","text":"Queues can be consumed in a batched manner using the batch() . See \"The Ferryman\" for a worked out example and its API documentation.","title":"Batching"},{"location":"collections/#list","text":"As alternative to the ordered queue, kalasim also provides a similarly instrumented list implementation with ComponentList . It's only providing very basic FiFo queue characteristics with poll() supported by its backend. The main intent for ComponentList are more sophisticated use-cases that can not be modelled with a single queue. Examples are Machine scheduling with more than instance Service models with different In such cases, a simple Comparator (even a chained one) are often insufficient to model the complex scheduling requirements.","title":"List"},{"location":"collections/#metrics","text":"Both, the ComponentList and the ComponentQueue provide a similar set of built-in metrics Monitors queueLengthMonitor tracks the queue length level across time lengthOfStayMonitor tracks the length of stay in the queue over time Statistics stats - Current state snapshot of queue statistics regarding length and length of stay info - Json-structured summary of the list/queue","title":"Metrics"},{"location":"component/","text":"Component Components are the key elements of a simulation. Components can be either in DATA or an ACTIVE lifecycle state. An ACTIVE component has one or more process definitions of which one was activated at some point in time. With activate() we can chang DATA components to ACTIVE if is has an associated process definition. An ACTIVE component can become DATA either with a cancel() or by reaching the end of a definition . It is very easy to create a DATA components val component = Component () Components will interact with each other through a well-defined vocabulary of process interaction methods. Info By default, Components will be named automatically, using the pattern [Class Name].[Instance Number] unless a custom name is provided via the name parameter in Component(name=\"Foo\") . Process Definition Although it is possible to create a component directly with val x = Component() , this makes it very hard to make that component into an active component, because there's no process method. So, nearly always we define our simulation entities by extending Component and by providing a process definition which details out the component's life cycle: Important The process definition of a component defines its dynamics and interplay with other simulation entities. Writing down the process definition is the key modelling task when using kalasim . If there is no process definition, a component will always be a data component. There are 3 supported methods to provide a process definition. 1. Extend process Let's start with the most common method. In order to make an active component it is necessary to extend Component to provide (at least) one sequence generator method, normally called process : class Car : Component (){ override fun process () = sequence { wait ( customerArrived ) request ( driver ){ hold ( 4 , \"driving\" ) } } } If we then say val car = Car() , a component is created, and it activated from process. This process is nearly always, but not necessarily a generator method (i.e. it has at least one yield statement). The result is that car is put on the future event list (for time now ) and when it's its turn, the component becomes CURRENT . It is also possible to set a time at which the component (car) becomes active, like val car = Car(at=10) . This requires an additional constructor argument to be passed on to Component as in class Car(at:Number): Component(delay=at) . Creation and activation are by default combined when creating a new Component instance: val car1 = Car () val car2 = Car () val car3 = Car () This causes three cars to be created and to be activated , that is scheduled for execution in the simulation's event queue . Normally, any process definition will contain at least one yield statement. By doing so, the component can hand-back control to the simulation engine at defined points when a component needs to wait. Typically, the user must not use yield directly, but rather the provided process interaction methods. 2. Extend repeatedProcess A very common pattern in process definition, iteratively executed processes. This could be modelled with class Machine : Component (){ override fun process () = sequence { while ( true ) { wait ( hasMaterial ) hold ( 7 , \"drilling\" ) } } } This can be expressed more elegantly with repeatedProcess : class Machine : Component (){ override fun repeatedProcess () = sequence { wait ( hasMaterial ) hold ( 7 , \"drilling\" ) } } Info Finally, if there is a process or repeatedProcess method, you can disable the automatic activation (i.e. make it a data component), by specifying Component(process = Component::none) . 3. Process Reference A component may be initialized to start at another process definition method. This is achieved by passing a reference to this method which must be part of the component's class definition, like val car = Car(process = Car::wash) . It is also possible to prepare multiple process definition, which may become active later by means of an activate() statement: ////CraneProcess.kts import org.kalasim.Component import org.kalasim.ProcessPointer import org.kalasim.createSimulation class Crane ( process : ProcessPointer? = Component :: process ) : Component ( process = Crane :: load ) { fun unload () = sequence < Component > { // hold, request, wait ... } fun load () = sequence < Component > { // hold, request, wait ... } } createSimulation { val crane1 = Crane () // load will be activated be default val crane2 = Crane ( process = Crane :: load ) // force unloading at start val crane3 = Crane ( process = Crane :: unload ) // force unloading at start crane3 . activate ( process = Crane :: load ) // activate other process } Effectively, creation and start of crane1 and crane2 is the same. Lifecycle A component is always in one of the following states modelled by org.kalasim.ComponentState : CURRENT - The component's process is currently being executed by the event queue SCHEDULED - The component is scheduled for future execution PASSIVE - The component is idle REQUESTING - The component is waiting for a resource requirement to be met WAITING - The component is waiting for a state predicate to be met STANDBY - The component was put on standby INTERRUPTED - The component was interrupted DATA - The component is non of the active states above. Components without a process definition are always in this state. A component's status is automatically tracked in the status level monitor component.statusMonitor . Thus, it possible to check how long a component has been in a particuar state with val passiveDuration = component . statusMonitor [ ComponentState . PASSIVE ] It is possible to print a histogram with all the statuses a component has been in with component . statusMonitor . printHistogram () Accumulated times in a particular state can be obtained with summed() and be printed to console or displayed with the selected graphics backend val timeInEachState = component . statusMonitor . summed () timeInEachState . printConsole () timeInEachState . display () Process Interaction The scheme below shows how interaction relate to component state transitions: from/to data current scheduled passive requesting waiting standby interrupted data activate 1 activate current process end yield hold yield passivate yield request yield wait yield standby . yield cancel yield activate scheduled cancel next event hold passivate request wait standby interrupt . activate passive cancel activate 1 activate request wait standby interrupt . hold 2 requesting cancel claim honor activate 3 passivate request wait standby interrupt . time out activate 4 waiting cancel wait honor activate 5 passivate wait wait standby interrupt . timeout activate 6 standby cancel next event activate passivate request wait interrupt interrupted cancel resume 7 resume 7 resume 7 resume 7 resume 7 interrupt 8 . activate passivate request wait standby Via scheduled() Not recommended With keepRequest = false (default) With keepRequest = true . This allows to set a new time out With keepWait = false (default) With keepWait = true . This allows to set a new timeout State at time of interrupt Increases the interruptLevel activate Activate will schedule execution at the specified time. If no time is specified, execution will be scheduled for the current simulation time. If you do not specify a process, the current process will be scheduled for continuation . If a process argument is provided, the process will be started (or restarted if it is equal to the currently active process). val car0 = Car ( process = null ) // data component car0 . activate () // activate @ process if exists, otherwise error val car1 = Car ( process = null ) // data component car1 . activate ( process = null ) // activate @ wash If the component to be activated is DATA , unless provided with process the default Component::process will be scheduled at the specified time. If the component to be activated is PASSIVE , the component will be activated at the specified time. If the component to be activated is SCHEDULED , the component will get a new scheduled time. If the component to be activated is REQUESTING , the request will be terminated, the attribute failed set, and the component will become scheduled. If keep_request=True is specified, only the fail_at will be updated, and the component will stay requesting. If the component to be activated is WAITING , the wait will be terminated, the attribute failed set, and the component will become scheduled. If keepWait=true is specified, only the failAt will be updated, and the component will stay waiting. If the component to be activated is STANDBY , the component will get a new scheduled time and become scheduled. If the component is INTERRUPTED , the component will be activated at the specified time. Note It is not possible to activate the CURRENT component, and kalasim will throw an error in this situation. The effect of a \"self\"-activate would be that the component becomes scheduled, thus this is essentially equivalent to the preferred hold method, so please use hold instead. In rare situations processes need to be restarted. If so, use yield for activation and provide the process pointer yield(activate(process = Component::process)) which will bypass the internal requirement that the activated component must not be CURRENT . Although not very common, it is possible to activate a component at a certain time or with a specified delay: ship1 . activate ( at = 100 ) ship2 . activate ( delay = 50 ) hold Hold is the way to make a - usually current - component scheduled . If the component is CURRENT , it will suspend execution internally, and the component becomes scheduled for the specified time If the component to be held is passive, the component becomes scheduled for the specified time. If the component to be held is scheduled, the component will be rescheduled for the specified time, thus essentially the same as activate. If the component to be held is standby, the component becomes scheduled for the specified time. If the component to be activated is requesting, the request will be terminated, the attribute failed set and the component will become scheduled. It is recommended to use the more versatile activate method. If the component to be activated is waiting, the wait will be terminated, the attribute failed set and the component will become scheduled. It is recommended to use the more versatile activate method. If the component is interrupted, the component will be activated at the specified time. passivate Passivate is the way to make a - usually current - component passive . This is essentially the same as scheduling for time=inf. If the component to be passivated is CURRENT , the component becomes passive, and it will suspend execution internally. If the component to be passivated is passive , the component remains passive . If the component to be passivated is scheduled , the component becomes passive . If the component to be held is standby , the component becomes passive . If the component to be activated is requesting, the request will be terminated, the attribute failed set and the component becomes passive. It is recommended to use the more versatile activate method. If the component to be activated is waiting, the wait will be terminated, the attribute failed set and the component becomes passive. It is recommended to use the more versatile activate method. If the component is interrupted, the component becomes passive. cancel Cancel has the effect that the component becomes a data component. If the component to be cancelled is CURRENT , it will suspend execution internally. If the component to be cancelled is passive , scheduled, interrupted or standby, the component becomes a data component. If the component to be cancelled is requesting , the request will be terminated, the attribute failed set, and the component becomes a data component. If the component to be cancelled is waiting, the wait will be terminated, the attribute failed set and the component becomes a data component. Examples Bank Office with Reneging standby Standby has the effect that the component will be triggered on the next simulation event. If the component is CURRENT , it will suspend execution internally Although theoretically possible, it is not recommended to use standby for non current components. If needed to do so, the pattern to provide the correct receiver is with(nonCurrent){ standby() } Not allowed for DATA components or main Examples Bank Office with Standby request Request has the effect that the component will check whether the requested quantity from a resource is available. It is possible to check for multiple availability of a certain quantity from several resources. Instead of checking for all of number of resources, it is also possible to check for any of a number of resources, by setting the oneOf parameter to true . By default, there is no limit on the time to wait for the resource(s) to become available. However, it is possible to set a time with failAt at which the condition has to be met. If that failed, the component becomes CURRENT at the given point of time. This is also known as reneging . If the component is canceled, activated, passivated, interrupted or held the failed flag will be set as well. If the component is CURRENT , it will suspend execution internally Although theoretically possible it is not recommended to use request for non current components. If needed to do so, the pattern to provide the correct receiver is with(nonCurrent){ request(r) } A component can also actively renege a pending request by calling release(resource) . See Bank3ClerksRenegingResources for an example (as well as Bank3ClerksReneging Bank3ClerksRenegingState for other supported reneging modes). wait Wait has the effect that the component will check whether the value of a state meets a given condition. It is possible to check for multiple states. By default, there is no limit on the time to wait for the condition(s) to be met. However, it is possible to set a time with failAt at which the condition has to be met. If that failed, the component becomes CURRENT at the given point of time. The code should then check whether the wait had failed. That can be checked with the Component.failed property. If the component is canceled , activated , passivated , interrupted or held the failed flag will be set as well. If the component is CURRENT , it will suspend execution internally Although theoretically possible it is not recommended to use wait for non current components. If needed to do so, the pattern to provide the correct receiver is with(nonCurrent){ wait() } Examples Gas Station interrupt With interrupt components that are not current or data can be temporarily be interrupted. Once a resume is called for the component, the component will continue (for scheduled with the remaining time, for waiting or requesting possibly with the remaining fail_at duration). Examples Machine Parts Usage of process interaction methods within a function or method There is a way to put process interaction statement in another function or method. This requires a slightly different way than just calling the method. As an example, let's assume that we want a method that holds a component for a number of minutes and that the time unit is actually seconds. So we need a method to wait 60 times the given parameter. We start with a not so elegant solution: object : Component () { override fun process () = sequence < Component > { hold ( 5.0 ) hold ( 5.0 ) } } Now we just add a method holdMinutes . Direct calling holdMinutes is not possible. Instead, we have to define an extension function on SequenceScope<Component> : object : Component () { override fun process () = sequence { holdMinutes () holdMinutes () } private suspend fun SequenceScope < Component > . holdMinutes () { hold ( 5.0 ) } } All process interaction statements including passivate , request and wait can be used that way! So remember if the method contains a yield statement (technically speaking iss a generator method), it should be called with from an extension function. Component Generator Since creation/generation of components is a very common element of most simulations, there is a dedicated utility called ComponentGenerator to do so ComponentGenerator ( iat = exponential ( lambda , rg )) { Customer () } It requires 2 main parameters 1. a builder pattern 2. an inter-arrival distribution See here for a complete listing of supported arguments. Examples Car Wash Gas Station ATM Queue","title":"Components"},{"location":"component/#component","text":"Components are the key elements of a simulation. Components can be either in DATA or an ACTIVE lifecycle state. An ACTIVE component has one or more process definitions of which one was activated at some point in time. With activate() we can chang DATA components to ACTIVE if is has an associated process definition. An ACTIVE component can become DATA either with a cancel() or by reaching the end of a definition . It is very easy to create a DATA components val component = Component () Components will interact with each other through a well-defined vocabulary of process interaction methods. Info By default, Components will be named automatically, using the pattern [Class Name].[Instance Number] unless a custom name is provided via the name parameter in Component(name=\"Foo\") .","title":"Component"},{"location":"component/#process-definition","text":"Although it is possible to create a component directly with val x = Component() , this makes it very hard to make that component into an active component, because there's no process method. So, nearly always we define our simulation entities by extending Component and by providing a process definition which details out the component's life cycle: Important The process definition of a component defines its dynamics and interplay with other simulation entities. Writing down the process definition is the key modelling task when using kalasim . If there is no process definition, a component will always be a data component. There are 3 supported methods to provide a process definition.","title":"Process Definition"},{"location":"component/#1-extend-process","text":"Let's start with the most common method. In order to make an active component it is necessary to extend Component to provide (at least) one sequence generator method, normally called process : class Car : Component (){ override fun process () = sequence { wait ( customerArrived ) request ( driver ){ hold ( 4 , \"driving\" ) } } } If we then say val car = Car() , a component is created, and it activated from process. This process is nearly always, but not necessarily a generator method (i.e. it has at least one yield statement). The result is that car is put on the future event list (for time now ) and when it's its turn, the component becomes CURRENT . It is also possible to set a time at which the component (car) becomes active, like val car = Car(at=10) . This requires an additional constructor argument to be passed on to Component as in class Car(at:Number): Component(delay=at) . Creation and activation are by default combined when creating a new Component instance: val car1 = Car () val car2 = Car () val car3 = Car () This causes three cars to be created and to be activated , that is scheduled for execution in the simulation's event queue . Normally, any process definition will contain at least one yield statement. By doing so, the component can hand-back control to the simulation engine at defined points when a component needs to wait. Typically, the user must not use yield directly, but rather the provided process interaction methods.","title":"1. Extend process"},{"location":"component/#2-extend-repeatedprocess","text":"A very common pattern in process definition, iteratively executed processes. This could be modelled with class Machine : Component (){ override fun process () = sequence { while ( true ) { wait ( hasMaterial ) hold ( 7 , \"drilling\" ) } } } This can be expressed more elegantly with repeatedProcess : class Machine : Component (){ override fun repeatedProcess () = sequence { wait ( hasMaterial ) hold ( 7 , \"drilling\" ) } } Info Finally, if there is a process or repeatedProcess method, you can disable the automatic activation (i.e. make it a data component), by specifying Component(process = Component::none) .","title":"2. Extend repeatedProcess"},{"location":"component/#3-process-reference","text":"A component may be initialized to start at another process definition method. This is achieved by passing a reference to this method which must be part of the component's class definition, like val car = Car(process = Car::wash) . It is also possible to prepare multiple process definition, which may become active later by means of an activate() statement: ////CraneProcess.kts import org.kalasim.Component import org.kalasim.ProcessPointer import org.kalasim.createSimulation class Crane ( process : ProcessPointer? = Component :: process ) : Component ( process = Crane :: load ) { fun unload () = sequence < Component > { // hold, request, wait ... } fun load () = sequence < Component > { // hold, request, wait ... } } createSimulation { val crane1 = Crane () // load will be activated be default val crane2 = Crane ( process = Crane :: load ) // force unloading at start val crane3 = Crane ( process = Crane :: unload ) // force unloading at start crane3 . activate ( process = Crane :: load ) // activate other process } Effectively, creation and start of crane1 and crane2 is the same.","title":"3. Process Reference"},{"location":"component/#lifecycle","text":"A component is always in one of the following states modelled by org.kalasim.ComponentState : CURRENT - The component's process is currently being executed by the event queue SCHEDULED - The component is scheduled for future execution PASSIVE - The component is idle REQUESTING - The component is waiting for a resource requirement to be met WAITING - The component is waiting for a state predicate to be met STANDBY - The component was put on standby INTERRUPTED - The component was interrupted DATA - The component is non of the active states above. Components without a process definition are always in this state. A component's status is automatically tracked in the status level monitor component.statusMonitor . Thus, it possible to check how long a component has been in a particuar state with val passiveDuration = component . statusMonitor [ ComponentState . PASSIVE ] It is possible to print a histogram with all the statuses a component has been in with component . statusMonitor . printHistogram () Accumulated times in a particular state can be obtained with summed() and be printed to console or displayed with the selected graphics backend val timeInEachState = component . statusMonitor . summed () timeInEachState . printConsole () timeInEachState . display ()","title":"Lifecycle"},{"location":"component/#process-interaction","text":"The scheme below shows how interaction relate to component state transitions: from/to data current scheduled passive requesting waiting standby interrupted data activate 1 activate current process end yield hold yield passivate yield request yield wait yield standby . yield cancel yield activate scheduled cancel next event hold passivate request wait standby interrupt . activate passive cancel activate 1 activate request wait standby interrupt . hold 2 requesting cancel claim honor activate 3 passivate request wait standby interrupt . time out activate 4 waiting cancel wait honor activate 5 passivate wait wait standby interrupt . timeout activate 6 standby cancel next event activate passivate request wait interrupt interrupted cancel resume 7 resume 7 resume 7 resume 7 resume 7 interrupt 8 . activate passivate request wait standby Via scheduled() Not recommended With keepRequest = false (default) With keepRequest = true . This allows to set a new time out With keepWait = false (default) With keepWait = true . This allows to set a new timeout State at time of interrupt Increases the interruptLevel","title":"Process Interaction"},{"location":"component/#activate","text":"Activate will schedule execution at the specified time. If no time is specified, execution will be scheduled for the current simulation time. If you do not specify a process, the current process will be scheduled for continuation . If a process argument is provided, the process will be started (or restarted if it is equal to the currently active process). val car0 = Car ( process = null ) // data component car0 . activate () // activate @ process if exists, otherwise error val car1 = Car ( process = null ) // data component car1 . activate ( process = null ) // activate @ wash If the component to be activated is DATA , unless provided with process the default Component::process will be scheduled at the specified time. If the component to be activated is PASSIVE , the component will be activated at the specified time. If the component to be activated is SCHEDULED , the component will get a new scheduled time. If the component to be activated is REQUESTING , the request will be terminated, the attribute failed set, and the component will become scheduled. If keep_request=True is specified, only the fail_at will be updated, and the component will stay requesting. If the component to be activated is WAITING , the wait will be terminated, the attribute failed set, and the component will become scheduled. If keepWait=true is specified, only the failAt will be updated, and the component will stay waiting. If the component to be activated is STANDBY , the component will get a new scheduled time and become scheduled. If the component is INTERRUPTED , the component will be activated at the specified time. Note It is not possible to activate the CURRENT component, and kalasim will throw an error in this situation. The effect of a \"self\"-activate would be that the component becomes scheduled, thus this is essentially equivalent to the preferred hold method, so please use hold instead. In rare situations processes need to be restarted. If so, use yield for activation and provide the process pointer yield(activate(process = Component::process)) which will bypass the internal requirement that the activated component must not be CURRENT . Although not very common, it is possible to activate a component at a certain time or with a specified delay: ship1 . activate ( at = 100 ) ship2 . activate ( delay = 50 )","title":"activate"},{"location":"component/#hold","text":"Hold is the way to make a - usually current - component scheduled . If the component is CURRENT , it will suspend execution internally, and the component becomes scheduled for the specified time If the component to be held is passive, the component becomes scheduled for the specified time. If the component to be held is scheduled, the component will be rescheduled for the specified time, thus essentially the same as activate. If the component to be held is standby, the component becomes scheduled for the specified time. If the component to be activated is requesting, the request will be terminated, the attribute failed set and the component will become scheduled. It is recommended to use the more versatile activate method. If the component to be activated is waiting, the wait will be terminated, the attribute failed set and the component will become scheduled. It is recommended to use the more versatile activate method. If the component is interrupted, the component will be activated at the specified time.","title":"hold"},{"location":"component/#passivate","text":"Passivate is the way to make a - usually current - component passive . This is essentially the same as scheduling for time=inf. If the component to be passivated is CURRENT , the component becomes passive, and it will suspend execution internally. If the component to be passivated is passive , the component remains passive . If the component to be passivated is scheduled , the component becomes passive . If the component to be held is standby , the component becomes passive . If the component to be activated is requesting, the request will be terminated, the attribute failed set and the component becomes passive. It is recommended to use the more versatile activate method. If the component to be activated is waiting, the wait will be terminated, the attribute failed set and the component becomes passive. It is recommended to use the more versatile activate method. If the component is interrupted, the component becomes passive.","title":"passivate"},{"location":"component/#cancel","text":"Cancel has the effect that the component becomes a data component. If the component to be cancelled is CURRENT , it will suspend execution internally. If the component to be cancelled is passive , scheduled, interrupted or standby, the component becomes a data component. If the component to be cancelled is requesting , the request will be terminated, the attribute failed set, and the component becomes a data component. If the component to be cancelled is waiting, the wait will be terminated, the attribute failed set and the component becomes a data component. Examples Bank Office with Reneging","title":"cancel"},{"location":"component/#standby","text":"Standby has the effect that the component will be triggered on the next simulation event. If the component is CURRENT , it will suspend execution internally Although theoretically possible, it is not recommended to use standby for non current components. If needed to do so, the pattern to provide the correct receiver is with(nonCurrent){ standby() } Not allowed for DATA components or main Examples Bank Office with Standby","title":"standby"},{"location":"component/#request","text":"Request has the effect that the component will check whether the requested quantity from a resource is available. It is possible to check for multiple availability of a certain quantity from several resources. Instead of checking for all of number of resources, it is also possible to check for any of a number of resources, by setting the oneOf parameter to true . By default, there is no limit on the time to wait for the resource(s) to become available. However, it is possible to set a time with failAt at which the condition has to be met. If that failed, the component becomes CURRENT at the given point of time. This is also known as reneging . If the component is canceled, activated, passivated, interrupted or held the failed flag will be set as well. If the component is CURRENT , it will suspend execution internally Although theoretically possible it is not recommended to use request for non current components. If needed to do so, the pattern to provide the correct receiver is with(nonCurrent){ request(r) } A component can also actively renege a pending request by calling release(resource) . See Bank3ClerksRenegingResources for an example (as well as Bank3ClerksReneging Bank3ClerksRenegingState for other supported reneging modes).","title":"request"},{"location":"component/#wait","text":"Wait has the effect that the component will check whether the value of a state meets a given condition. It is possible to check for multiple states. By default, there is no limit on the time to wait for the condition(s) to be met. However, it is possible to set a time with failAt at which the condition has to be met. If that failed, the component becomes CURRENT at the given point of time. The code should then check whether the wait had failed. That can be checked with the Component.failed property. If the component is canceled , activated , passivated , interrupted or held the failed flag will be set as well. If the component is CURRENT , it will suspend execution internally Although theoretically possible it is not recommended to use wait for non current components. If needed to do so, the pattern to provide the correct receiver is with(nonCurrent){ wait() } Examples Gas Station","title":"wait"},{"location":"component/#interrupt","text":"With interrupt components that are not current or data can be temporarily be interrupted. Once a resume is called for the component, the component will continue (for scheduled with the remaining time, for waiting or requesting possibly with the remaining fail_at duration). Examples Machine Parts","title":"interrupt"},{"location":"component/#usage-of-process-interaction-methods-within-a-function-or-method","text":"There is a way to put process interaction statement in another function or method. This requires a slightly different way than just calling the method. As an example, let's assume that we want a method that holds a component for a number of minutes and that the time unit is actually seconds. So we need a method to wait 60 times the given parameter. We start with a not so elegant solution: object : Component () { override fun process () = sequence < Component > { hold ( 5.0 ) hold ( 5.0 ) } } Now we just add a method holdMinutes . Direct calling holdMinutes is not possible. Instead, we have to define an extension function on SequenceScope<Component> : object : Component () { override fun process () = sequence { holdMinutes () holdMinutes () } private suspend fun SequenceScope < Component > . holdMinutes () { hold ( 5.0 ) } } All process interaction statements including passivate , request and wait can be used that way! So remember if the method contains a yield statement (technically speaking iss a generator method), it should be called with from an extension function.","title":"Usage of process interaction methods within a function or method"},{"location":"component/#component-generator","text":"Since creation/generation of components is a very common element of most simulations, there is a dedicated utility called ComponentGenerator to do so ComponentGenerator ( iat = exponential ( lambda , rg )) { Customer () } It requires 2 main parameters 1. a builder pattern 2. an inter-arrival distribution See here for a complete listing of supported arguments. Examples Car Wash Gas Station ATM Queue","title":"Component Generator"},{"location":"event_log/","text":"Events To analyze state changes in a simulation model, we may want to monitor component creation, the event queue , or the interplay between simulation entities. We may want to trace which process caused an event, or which processes waited for resource. Or a model may require other custom state change events to be monitored. kalasim triggers a rich set of built-int events, which are gathered automatically for interactions , entity creation, and resource requests . It also allows for custom event types that can be triggered in process definitions . The event log is modelled as a sequence of org.kalasim.Event s that can be consumed with one more multiple org.kalasim.EventListener s. The classical publish-subscribe pattern is used here. Consumers can easily route events into such as consoles, files, rest-endpoints, databases, or in-place-analytics. To get started, we can register new event handlers with addEventListener(org.kalasim.EventListener) . Since an EventListener is modelled as a functional interface , the syntax is very concise: createSimulation { addEventListener { it : Event -> println ( it )} } Event listener implementations typically do not want to consume all events but filter for specific types or simulation entities. This filtering can be implemented in the listener or by providing a the type of interest, when adding the listener. import org.kalasim.* class MyEvent ( val context : String , time : TickTime ) : Event ( time ) createSimulation { addEventListener < MyEvent > { println ( it . context )} } In this example, we have created custom simulation event type. This approach is very common: By using custom event types when building process models with kalasim state changes can be consumed very selectively in analysis and visualization. Console Logger There are a few provided event listeners, most notable the built-int console logger. With console logging being enabled, we get the following output (displayed as table for convenience): time current component component action info --------- ------------------------ ------------------------ ----------- ----------------------------- .00 main DATA create .00 main .00 Car.1 DATA create .00 Car.1 DATA activate .00 main CURRENT run +5.0 .00 Car.1 .00 Car.1 CURRENT hold +1.0 1.00 Car.1 CURRENT 1.00 Car.1 DATA ended 5.00 main Process finished with exit code 0 Console logging is not active by default as it would considerably slow down larger simulations, and but must be enabled when creating a simulation with createSimulation(enableConsoleLogger = true) Note The user can change the width of individual columns with ConsoleTraceLogger.setColumnWidth() Event Collector A more selective monitor that will just events of a certain type is the event collector. It needs to be created before running the simulation (or from the moment when events shall be collected). class MyEvent ( time : TickTime ) : Event ( time ) // run the sim which create many events including some MyEvents env . run () val myEvents : List < MyEvent > = eventCollector < MyEvent > () // e.g. save them into a csv file with krangl myEvents . asDataFrame (). writeCsv ( File ( \"my_events.csv\" )) This collector will have a much reduced memory footprint compared to the event log . Event Log Another built-in event listener is the trace collector, which simply records all events and puts them in a list for later analysis. For example to fetch all events in retrospect related to resource requests we could filter by the corresponding event type ////EventCollector.kts import org.kalasim.* createSimulation ( enableConsoleLogger = true ) { val tc = eventLog () tc . filter { it is InteractionEvent && it . source ?. name == \"foo\" } val claims = tc // . filterIsInstance < ResourceEvent > () . filter { it . type == ResourceEventType . CLAIMED } }. run ( 5.0 ) Asynchronous Event Consumption Sometimes, events can not be consumed in the simulation thread, but must be processed asynchronously. To do so we could use a custom thread or we could setup a coroutines channel for log events to be consumed asynchronously. These technicalities are already internalized in addAsyncEventLister which can be parameterized with a custom coroutine scope if needed. So to consume, events asynchronously, we can do: ////LogChannelConsumerDsl.kt import org.kalasim.* createSimulation { ComponentGenerator ( iat = constant ( 1 )) { Component ( \"Car. ${ it } \" ) } // add custom log consumer addAsyncEventListener < InteractionEvent > { event -> if ( event . curComponent ?. name == \"ComponentGenerator.1\" ) println ( event ) } // run the simulation run ( 10 ) } In the example, we can think of a channel as a pipe between two coroutines. For details see the great article Kotlin: Diving in to Coroutines and Channels . Logging Configuration Typically, only some types of event logging are required in a given simulation. To optimize simulation performance, the engine allows to suppress selectively per event type and simulation entity. This is configured via tracking policy factory Tabular Interface A typesafe data-structure is usually the preferred for modelling. However, accessing data in a tabular format can also be helpful to enable statistical analyses. Enabled by krangl's Iterable<T>.asDataFrame() extension, we can transform records, events and simulation entities easily into tables. This also provides a semantic compatibility layer with other DES engines (such as simmer ), that are centered around tables for model analysis. We can apply such a transformation simulation Event s. For example, we can apply an instance filter to the recorded log to extract only log records relating to resource requests. These can be transformed and converted to a csv with just: // ... add your simulation here ... data class RequestRecord ( val requester : String , val timestamp : Double , val resource : String , val quantity : Double ) val tc = sim . get < TraceCollector > () val requests = tc . filterIsInstance < ResourceEvent > (). map { val amountDirected = ( if ( it . type == ResourceEventType . RELEASED ) - 1 else 1 ) * it . amount RequestRecord ( it . requester . name , it . time , it . resource . name , amountDirected ) } // transform data into data-frame (for visualization and stats) requests . asDataFrame (). writeCSV ( \"requests.csv\" ) The transformation step is optional, List<Event> can be transformed asDataFrame() directly. Events in Jupyter When working with jupyter, we can harvest the kernel's built-in rendering capabilities to render events. Note that we need to filter for specific event type to capture all attributes. For a fully worked out example see","title":"Event Log"},{"location":"event_log/#events","text":"To analyze state changes in a simulation model, we may want to monitor component creation, the event queue , or the interplay between simulation entities. We may want to trace which process caused an event, or which processes waited for resource. Or a model may require other custom state change events to be monitored. kalasim triggers a rich set of built-int events, which are gathered automatically for interactions , entity creation, and resource requests . It also allows for custom event types that can be triggered in process definitions . The event log is modelled as a sequence of org.kalasim.Event s that can be consumed with one more multiple org.kalasim.EventListener s. The classical publish-subscribe pattern is used here. Consumers can easily route events into such as consoles, files, rest-endpoints, databases, or in-place-analytics. To get started, we can register new event handlers with addEventListener(org.kalasim.EventListener) . Since an EventListener is modelled as a functional interface , the syntax is very concise: createSimulation { addEventListener { it : Event -> println ( it )} } Event listener implementations typically do not want to consume all events but filter for specific types or simulation entities. This filtering can be implemented in the listener or by providing a the type of interest, when adding the listener. import org.kalasim.* class MyEvent ( val context : String , time : TickTime ) : Event ( time ) createSimulation { addEventListener < MyEvent > { println ( it . context )} } In this example, we have created custom simulation event type. This approach is very common: By using custom event types when building process models with kalasim state changes can be consumed very selectively in analysis and visualization.","title":"Events"},{"location":"event_log/#console-logger","text":"There are a few provided event listeners, most notable the built-int console logger. With console logging being enabled, we get the following output (displayed as table for convenience): time current component component action info --------- ------------------------ ------------------------ ----------- ----------------------------- .00 main DATA create .00 main .00 Car.1 DATA create .00 Car.1 DATA activate .00 main CURRENT run +5.0 .00 Car.1 .00 Car.1 CURRENT hold +1.0 1.00 Car.1 CURRENT 1.00 Car.1 DATA ended 5.00 main Process finished with exit code 0 Console logging is not active by default as it would considerably slow down larger simulations, and but must be enabled when creating a simulation with createSimulation(enableConsoleLogger = true) Note The user can change the width of individual columns with ConsoleTraceLogger.setColumnWidth()","title":"Console Logger"},{"location":"event_log/#event-collector","text":"A more selective monitor that will just events of a certain type is the event collector. It needs to be created before running the simulation (or from the moment when events shall be collected). class MyEvent ( time : TickTime ) : Event ( time ) // run the sim which create many events including some MyEvents env . run () val myEvents : List < MyEvent > = eventCollector < MyEvent > () // e.g. save them into a csv file with krangl myEvents . asDataFrame (). writeCsv ( File ( \"my_events.csv\" )) This collector will have a much reduced memory footprint compared to the event log .","title":"Event Collector"},{"location":"event_log/#event-log","text":"Another built-in event listener is the trace collector, which simply records all events and puts them in a list for later analysis. For example to fetch all events in retrospect related to resource requests we could filter by the corresponding event type ////EventCollector.kts import org.kalasim.* createSimulation ( enableConsoleLogger = true ) { val tc = eventLog () tc . filter { it is InteractionEvent && it . source ?. name == \"foo\" } val claims = tc // . filterIsInstance < ResourceEvent > () . filter { it . type == ResourceEventType . CLAIMED } }. run ( 5.0 )","title":"Event Log"},{"location":"event_log/#asynchronous-event-consumption","text":"Sometimes, events can not be consumed in the simulation thread, but must be processed asynchronously. To do so we could use a custom thread or we could setup a coroutines channel for log events to be consumed asynchronously. These technicalities are already internalized in addAsyncEventLister which can be parameterized with a custom coroutine scope if needed. So to consume, events asynchronously, we can do: ////LogChannelConsumerDsl.kt import org.kalasim.* createSimulation { ComponentGenerator ( iat = constant ( 1 )) { Component ( \"Car. ${ it } \" ) } // add custom log consumer addAsyncEventListener < InteractionEvent > { event -> if ( event . curComponent ?. name == \"ComponentGenerator.1\" ) println ( event ) } // run the simulation run ( 10 ) } In the example, we can think of a channel as a pipe between two coroutines. For details see the great article Kotlin: Diving in to Coroutines and Channels .","title":"Asynchronous Event Consumption"},{"location":"event_log/#logging-configuration","text":"Typically, only some types of event logging are required in a given simulation. To optimize simulation performance, the engine allows to suppress selectively per event type and simulation entity. This is configured via tracking policy factory","title":"Logging Configuration"},{"location":"event_log/#tabular-interface","text":"A typesafe data-structure is usually the preferred for modelling. However, accessing data in a tabular format can also be helpful to enable statistical analyses. Enabled by krangl's Iterable<T>.asDataFrame() extension, we can transform records, events and simulation entities easily into tables. This also provides a semantic compatibility layer with other DES engines (such as simmer ), that are centered around tables for model analysis. We can apply such a transformation simulation Event s. For example, we can apply an instance filter to the recorded log to extract only log records relating to resource requests. These can be transformed and converted to a csv with just: // ... add your simulation here ... data class RequestRecord ( val requester : String , val timestamp : Double , val resource : String , val quantity : Double ) val tc = sim . get < TraceCollector > () val requests = tc . filterIsInstance < ResourceEvent > (). map { val amountDirected = ( if ( it . type == ResourceEventType . RELEASED ) - 1 else 1 ) * it . amount RequestRecord ( it . requester . name , it . time , it . resource . name , amountDirected ) } // transform data into data-frame (for visualization and stats) requests . asDataFrame (). writeCSV ( \"requests.csv\" ) The transformation step is optional, List<Event> can be transformed asDataFrame() directly.","title":"Tabular Interface"},{"location":"event_log/#events-in-jupyter","text":"When working with jupyter, we can harvest the kernel's built-in rendering capabilities to render events. Note that we need to filter for specific event type to capture all attributes. For a fully worked out example see","title":"Events in Jupyter"},{"location":"examples/","text":"There's nothing more intriguing than a good example. To provide guidance we tried to categorize our examples by difficulty. Categorization is opinionated and just tries to pave an entry path into kalasim API. Simple Car - A single car, a driver, and red traffic light in the middle of the night. The thrilling landing page example but this time fully documented with an extensive code-walkthrough. Traffic - Car navigate through a simple traffic model with crossings and traffic-lights. Clearly, they need to refill, but there is just a limited number of slots as the gas station. Bank Office with 1 clerk - A classic queue, where customers arrive at a bank and need to be serviced Bridge Game - A survival analysis of murderous game in Netflix' famous Squid Games series. Moderate Movie Theater - A big cinema, great movies. How long does it take before tickets are sold out? Car Wash - A car wash with limited throughput, and a continuous stream of new customers Machine Parts - A small shop-floor with multi-part machines, where all parts must be functional to avoid tool downtime Machine Shop - A day in a life of a busy maintenance engineer. Tools break and need to be repaired before they can continue operation The Ferryman - A wild river, one boat only, and a patient ferryman transporting batches of passengers across the body of water Elaborate ATM - The canonical queue model. Here, illustrated with a cash machine that needs to serve customers. Gas Station - A gas-station again, but this time the focus is on the station itself and how it struggls to get new petrol to serve hungry customers. Bank Office - A classical queue problem where customers need to be served. Here solved 4 times in different ways using different kalasim models. Dining Philosophers - Philosophers sit at a round table with bowls of spaghetti and try to eat. It ain't easy... Office Tower - A busy office building, where workers need to get from floor to floor using a limited number of elevators.","title":"Overview"},{"location":"faq/","text":"F.A.Q. Why rebuilding salabim ? Great question! Initial development was driven by curiosity about the salabim internals. Also, it lacked (arguably) a modern touch which made some of our use cases more tricky to implement. kalasim implements the great majority of salabim features as documented under https://www.salabim.org/manual/ including Components ComponentGenerator Queue Distributions (via apache-commons-math) Monitor Resource State Not planned Animation - which we believe should live in a separate codebase. Visualization in kalasim is detailed out in the visualization chapter . What (TF) is the meaning of kalasim ? We went through multiple iterations to come up with this great name: desimuk - {d}iscrete {e}vent {simu}lation with {k}otlin seemed a very natural and great fit. Unfortunately, Google seemed more convinced - for reasons that were outside the scope of this project - that this name related mostly with indian porn. desim - seemed fine initially, until we discovered another simulation engine https://github.com/aybabtme/desim with the same name. kalasim honors its origin by being somewhat phonetically similar to salabim while stressing Kotlin with the k , and the simulation scope with the sim instead of the bim . In case you also wonder why salabim was named salabim , see here . Can we use it with from Java? Kotlin-2-Java interop is a core design goal of Kotlin. Thus, kalasim should work without any issues from java. However, we have not tried yet, so in case you struggle please file a ticket. Why can we use resource.request(1)? Admittedly, the provided resource request syntax request(resource) feels a bit dated. It's designed in that way because we would need multiple receiver support for extensions functions to provide a more object-oriented API. However, extensions with multiple receivers are not (yet) supported by Kotlin. How to fix KoinApplication has not been started ? You would need to create a simulation context before instantiating the resources, components or states. E.g. with Environment (). apply { val devices = Resource ( name = \"devices\" , capacity = 3 ) } For more details regarding koin and dependency injection see https://www.kalasim.org/basics/#dependency-injection","title":"FAQ"},{"location":"faq/#faq","text":"","title":"F.A.Q."},{"location":"faq/#why-rebuilding-salabim","text":"Great question! Initial development was driven by curiosity about the salabim internals. Also, it lacked (arguably) a modern touch which made some of our use cases more tricky to implement. kalasim implements the great majority of salabim features as documented under https://www.salabim.org/manual/ including Components ComponentGenerator Queue Distributions (via apache-commons-math) Monitor Resource State Not planned Animation - which we believe should live in a separate codebase. Visualization in kalasim is detailed out in the visualization chapter .","title":"Why rebuilding salabim?"},{"location":"faq/#what-tf-is-the-meaning-of-kalasim","text":"We went through multiple iterations to come up with this great name: desimuk - {d}iscrete {e}vent {simu}lation with {k}otlin seemed a very natural and great fit. Unfortunately, Google seemed more convinced - for reasons that were outside the scope of this project - that this name related mostly with indian porn. desim - seemed fine initially, until we discovered another simulation engine https://github.com/aybabtme/desim with the same name. kalasim honors its origin by being somewhat phonetically similar to salabim while stressing Kotlin with the k , and the simulation scope with the sim instead of the bim . In case you also wonder why salabim was named salabim , see here .","title":"What (TF) is the meaning of kalasim?"},{"location":"faq/#can-we-use-it-with-from-java","text":"Kotlin-2-Java interop is a core design goal of Kotlin. Thus, kalasim should work without any issues from java. However, we have not tried yet, so in case you struggle please file a ticket.","title":"Can we use it with from Java?"},{"location":"faq/#why-can-we-use-resourcerequest1","text":"Admittedly, the provided resource request syntax request(resource) feels a bit dated. It's designed in that way because we would need multiple receiver support for extensions functions to provide a more object-oriented API. However, extensions with multiple receivers are not (yet) supported by Kotlin.","title":"Why can we use resource.request(1)?"},{"location":"faq/#how-to-fix-koinapplication-has-not-been-started","text":"You would need to create a simulation context before instantiating the resources, components or states. E.g. with Environment (). apply { val devices = Resource ( name = \"devices\" , capacity = 3 ) } For more details regarding koin and dependency injection see https://www.kalasim.org/basics/#dependency-injection","title":"How to fix KoinApplication has not been started?"},{"location":"getting_started/","text":"How to get started with kalasim ? Depending on your prior experience with simulation and programming, it may take time to become fluent with kalasim . To streamline the learning experience, we've organized our learning process suggestions by audience. I have experience with simulation Start by doing a crash course to learn some kotlin programming basics Run the provided simulation examples in datalore in your browser Pick your favorite example and try converting it into a datalore notebook Try visualizing some metrics using the built-in visualization methods I have experience with programming Download the community edition of Intellij IDEA Follow the instructions to create a Kotlin application Add kalasim as a dependency as described in the setup Understand the fundamentals of simulation and the main simulation entities Pick you favorite example and work it out towards your own interest/use-cases Get in touch Feel welcome to get in touch with us for support, consulting and discussion.","title":"Getting Started"},{"location":"getting_started/#how-to-get-started-with-kalasim","text":"Depending on your prior experience with simulation and programming, it may take time to become fluent with kalasim . To streamline the learning experience, we've organized our learning process suggestions by audience.","title":"How to get started with kalasim?"},{"location":"getting_started/#i-have-experience-with-simulation","text":"Start by doing a crash course to learn some kotlin programming basics Run the provided simulation examples in datalore in your browser Pick your favorite example and try converting it into a datalore notebook Try visualizing some metrics using the built-in visualization methods","title":"I have experience with simulation"},{"location":"getting_started/#i-have-experience-with-programming","text":"Download the community edition of Intellij IDEA Follow the instructions to create a Kotlin application Add kalasim as a dependency as described in the setup Understand the fundamentals of simulation and the main simulation entities Pick you favorite example and work it out towards your own interest/use-cases","title":"I have experience with programming"},{"location":"getting_started/#get-in-touch","text":"Feel welcome to get in touch with us for support, consulting and discussion.","title":"Get in touch"},{"location":"monitors/","text":"Monitors Monitors are a way to collect data from the simulation. They are automatically collected for resources , components , states and collections . On top of that the user can define her own monitors. Monitors can be used to get statistics and as a feed for graphical tools. There are two types of monitors: Level monitors are useful to collect data about a variable that keeps its value over a certain length of time, such as the length of a queue or the color of a traffic light. Non-level monitors are useful to collect data about that occur just once. Examples, are the length of stay in a queue, or the number of processing steps of a part. For both types, the time is always collected, along with the value. Monitors support a wide range of statistical properties via m.statistics() including mean median percentiles min and max standard deviation histograms For all these statistics, it is possible to exclude zero entries, e.g. m.statistics(statistics=true) returns the mean, excluding zero entries. Monitors can be disabled with disable() by setting the boolean flag ``. m . disable () // disable monitoring m . reset () // reenable statistics monitoring m . reset ( initialValue ) // reenable level monitoring Continuation of a temporarily disabled monitor is currently not supported. Non level monitors Non-level monitors collects values which do not reflect a level, e.g. the processing time of a part. There are 2 implementations to support categorical and numerical attributes org.kalasim.NumericStatisticMonitor org.kalasim.FrequencyMonitor Besides, it is possible to get all collected values as list with m.statistics().values . Calling m.reset() will clear all tallied values. Level monitor Level monitors tally levels along with the current (simulation) time. E.g. the number of parts a machine is working on. There are 2 implementations to support categorical and numerical attributes org.kalasim.CategoryTimeline org.kalasim.MetricTimeline Level monitors allow to query the value at a specific time val nlm = MetricTimeline () // ... collecting some data ... nlm [ 4 ] // will print the value at time 4 In addition to standard statistics, level monitor support the following statistics duration For all statistics, it is possible to exclude zero entries, e.g. m.statistics(excludeZeros=true).mean returns the mean, excluding zero entries. {todo} implement off tallying Calling m.reset() will clear all tallied values and timestamps. The statistics of a level monitor can be printed with m.printStatistics() . Histograms The statistics of a monitor can be printed with printStatistics() . E.g: waitingLine.lengthOfStayMonitor.printStatistics() : { \"all\" : { \"entries\" : 5 , \"ninety_pct_quantile\" : 4.142020545932034 , \"median\" : 1.836 , \"mean\" : 1.211 , \"ninetyfive_pct_quantile\" : 4.142020545932034 , \"standard_deviation\" : 1.836 }, \"excl_zeros\" : { \"entries\" : 2 , \"ninety_pct_quantile\" : 4.142020545932034 , \"median\" : 1.576 , \"mean\" : 3.027 , \"ninetyfive_pct_quantile\" : 4.142020545932034 , \"standard_deviation\" : 1.576 } } And, a histogram can be printed with printHistogram() . E.g. waitingLine.lengthOfStayMonitor.printHistogram() : Histogram of: 'Available quantity of fuel_pump' bin | entries | pct | [146.45, 151.81] | 1 | .33 | ************* [151.81, 157.16] | 0 | .00 | [157.16, 162.52] | 0 | .00 | [162.52, 167.87] | 0 | .00 | [167.87, 173.23] | 1 | .33 | ************* [173.23, 178.58] | 0 | .00 | [178.58, 183.94] | 0 | .00 | [183.94, 189.29] | 0 | .00 | [189.29, 194.65] | 0 | .00 | [194.65, 200.00] | 1 | .33 | ************* If neither binCount , nor lowerBound nor upperBound are specified, the histogram will be autoscaled. Histograms can be printed with their values, instead of bins. This is particularly useful for non numeric tallied values, such as names:: val m = FrequencyMonitor < Car > () m . addValue ( AUDI ) m . addValue ( AUDI ) m . addValue ( VW ) repeat ( 4 ) { m . addValue ( PORSCHE )} m . printHistogram () The output of this: Summary of: 'FrequencyMonitor.2' # Records: 7 # Levels: 3 Histogram of: 'FrequencyMonitor.2' bin | entries | pct | AUDI | 2 | .29 | *********** VW | 1 | .14 | ****** PORSCHE | 4 | .57 | *********************** It is also possible to specify the values to be shown: m.printHistogram(values = listOf(AUDI, TOYOTA)) This results in a further aggregated histogram view where non-selected values are agregated and listes values are forced in the display even if they were not observed. Summary of: 'FrequencyMonitor.1' # Records: 7 # Levels: 3 Histogram of: 'FrequencyMonitor.1' bin | entries | pct | AUDI | 2 | .29 | *********** TOYOTA | 0 | .00 | rest | 5 | .71 | ***************************** It is also possible to sort the histogram on the weight (or number of entries) of the value: m.printHistogram(sortByWeight = true) The output of this: Summary of: 'FrequencyMonitor.1' # Records: 7 # Levels: 3 Histogram of: 'FrequencyMonitor.1' bin | entries | pct | PORSCHE | 4 | .57 | *********************** AUDI | 2 | .29 | *********** VW | 1 | .14 | ****** For numeric monitors it is possible to show values instead of ranges as bins val nlm = MetricTimeline () now += 2 nlm . addValue ( 2 ) now += 2 nlm . addValue ( 6 ) now += 4 nlm . printHistogram ( valueBins = false ) nlm . printHistogram ( valueBins = true ) which will result by default in Histogram of: 'MetricTimeline.1' bin | entries | pct | [.00, .60] | 232 | .23 | ********* [.60, 1.20] | 0 | .00 | [1.20, 1.80] | 0 | .00 | [1.80, 2.40] | 233 | .23 | ********* [2.40, 3.00] | 0 | .00 | [3.00, 3.60] | 0 | .00 | [3.60, 4.20] | 0 | .00 | [4.20, 4.80] | 0 | .00 | [4.80, 5.40] | 0 | .00 | [5.40, 6.00] | 535 | .54 | ********************* However, when valueBins is enabled the histogram becomes Histogram of: 'MetricTimeline.1' bin | entries | pct | 0.0 | 2 | .25 | ********** 2.0 | 2 | .25 | ********** 6.0 | 4 | .50 | ******************** Merging of Monitors Tt is possible to merge the resulting statistics of multiple monitors val flmA = CategoryTimeline ( 1 ) val flmB = CategoryTimeline ( 2 ) // ... run simulation val mergedStats : EnumeratedDistribution < Int > = listOf ( flmA , flmB ). mergeStats () See MergeMonitorTests for more examples regarding the other monitor types. Slicing of monitors Note : Slicing of monitors as in salabim is not yet supported. If needed please file a ticket . Use-cases for slicing are to get statistics on a monitor with respect to a given time period, most likely a subrun to get statistics on a monitor with respect to a recurring time period, like hour 0-1, hour 0-2, etc. Summarizing a monitor Monitor.statistics() returns a 'frozen' monitor that can be used to store the results not depending on the current environment. This is particularly useful for persisting monitor statistics for later analysis. Visualization It is possible to render monitors with the following extension functions NumericStatisticMonitor . display () MetricTimeline . display () In particular multiple outputs are supported here by the underlying kravis visualization windows, which allows forward backward navigation (via the arrow buttons). See org.kalasim.examples.bank.resources.Bank3ClerksResources for an example where multiple visualizing are combined to inspect the internal state of the simulation. Note that, currently monitor visualization just works in retrospect, and it is not (yet) possible to view the progression while a simulation is still running.","title":"Monitors"},{"location":"monitors/#monitors","text":"Monitors are a way to collect data from the simulation. They are automatically collected for resources , components , states and collections . On top of that the user can define her own monitors. Monitors can be used to get statistics and as a feed for graphical tools. There are two types of monitors: Level monitors are useful to collect data about a variable that keeps its value over a certain length of time, such as the length of a queue or the color of a traffic light. Non-level monitors are useful to collect data about that occur just once. Examples, are the length of stay in a queue, or the number of processing steps of a part. For both types, the time is always collected, along with the value. Monitors support a wide range of statistical properties via m.statistics() including mean median percentiles min and max standard deviation histograms For all these statistics, it is possible to exclude zero entries, e.g. m.statistics(statistics=true) returns the mean, excluding zero entries. Monitors can be disabled with disable() by setting the boolean flag ``. m . disable () // disable monitoring m . reset () // reenable statistics monitoring m . reset ( initialValue ) // reenable level monitoring Continuation of a temporarily disabled monitor is currently not supported.","title":"Monitors"},{"location":"monitors/#non-level-monitors","text":"Non-level monitors collects values which do not reflect a level, e.g. the processing time of a part. There are 2 implementations to support categorical and numerical attributes org.kalasim.NumericStatisticMonitor org.kalasim.FrequencyMonitor Besides, it is possible to get all collected values as list with m.statistics().values . Calling m.reset() will clear all tallied values.","title":"Non level monitors"},{"location":"monitors/#level-monitor","text":"Level monitors tally levels along with the current (simulation) time. E.g. the number of parts a machine is working on. There are 2 implementations to support categorical and numerical attributes org.kalasim.CategoryTimeline org.kalasim.MetricTimeline Level monitors allow to query the value at a specific time val nlm = MetricTimeline () // ... collecting some data ... nlm [ 4 ] // will print the value at time 4 In addition to standard statistics, level monitor support the following statistics duration For all statistics, it is possible to exclude zero entries, e.g. m.statistics(excludeZeros=true).mean returns the mean, excluding zero entries. {todo} implement off tallying Calling m.reset() will clear all tallied values and timestamps. The statistics of a level monitor can be printed with m.printStatistics() .","title":"Level monitor"},{"location":"monitors/#histograms","text":"The statistics of a monitor can be printed with printStatistics() . E.g: waitingLine.lengthOfStayMonitor.printStatistics() : { \"all\" : { \"entries\" : 5 , \"ninety_pct_quantile\" : 4.142020545932034 , \"median\" : 1.836 , \"mean\" : 1.211 , \"ninetyfive_pct_quantile\" : 4.142020545932034 , \"standard_deviation\" : 1.836 }, \"excl_zeros\" : { \"entries\" : 2 , \"ninety_pct_quantile\" : 4.142020545932034 , \"median\" : 1.576 , \"mean\" : 3.027 , \"ninetyfive_pct_quantile\" : 4.142020545932034 , \"standard_deviation\" : 1.576 } } And, a histogram can be printed with printHistogram() . E.g. waitingLine.lengthOfStayMonitor.printHistogram() : Histogram of: 'Available quantity of fuel_pump' bin | entries | pct | [146.45, 151.81] | 1 | .33 | ************* [151.81, 157.16] | 0 | .00 | [157.16, 162.52] | 0 | .00 | [162.52, 167.87] | 0 | .00 | [167.87, 173.23] | 1 | .33 | ************* [173.23, 178.58] | 0 | .00 | [178.58, 183.94] | 0 | .00 | [183.94, 189.29] | 0 | .00 | [189.29, 194.65] | 0 | .00 | [194.65, 200.00] | 1 | .33 | ************* If neither binCount , nor lowerBound nor upperBound are specified, the histogram will be autoscaled. Histograms can be printed with their values, instead of bins. This is particularly useful for non numeric tallied values, such as names:: val m = FrequencyMonitor < Car > () m . addValue ( AUDI ) m . addValue ( AUDI ) m . addValue ( VW ) repeat ( 4 ) { m . addValue ( PORSCHE )} m . printHistogram () The output of this: Summary of: 'FrequencyMonitor.2' # Records: 7 # Levels: 3 Histogram of: 'FrequencyMonitor.2' bin | entries | pct | AUDI | 2 | .29 | *********** VW | 1 | .14 | ****** PORSCHE | 4 | .57 | *********************** It is also possible to specify the values to be shown: m.printHistogram(values = listOf(AUDI, TOYOTA)) This results in a further aggregated histogram view where non-selected values are agregated and listes values are forced in the display even if they were not observed. Summary of: 'FrequencyMonitor.1' # Records: 7 # Levels: 3 Histogram of: 'FrequencyMonitor.1' bin | entries | pct | AUDI | 2 | .29 | *********** TOYOTA | 0 | .00 | rest | 5 | .71 | ***************************** It is also possible to sort the histogram on the weight (or number of entries) of the value: m.printHistogram(sortByWeight = true) The output of this: Summary of: 'FrequencyMonitor.1' # Records: 7 # Levels: 3 Histogram of: 'FrequencyMonitor.1' bin | entries | pct | PORSCHE | 4 | .57 | *********************** AUDI | 2 | .29 | *********** VW | 1 | .14 | ****** For numeric monitors it is possible to show values instead of ranges as bins val nlm = MetricTimeline () now += 2 nlm . addValue ( 2 ) now += 2 nlm . addValue ( 6 ) now += 4 nlm . printHistogram ( valueBins = false ) nlm . printHistogram ( valueBins = true ) which will result by default in Histogram of: 'MetricTimeline.1' bin | entries | pct | [.00, .60] | 232 | .23 | ********* [.60, 1.20] | 0 | .00 | [1.20, 1.80] | 0 | .00 | [1.80, 2.40] | 233 | .23 | ********* [2.40, 3.00] | 0 | .00 | [3.00, 3.60] | 0 | .00 | [3.60, 4.20] | 0 | .00 | [4.20, 4.80] | 0 | .00 | [4.80, 5.40] | 0 | .00 | [5.40, 6.00] | 535 | .54 | ********************* However, when valueBins is enabled the histogram becomes Histogram of: 'MetricTimeline.1' bin | entries | pct | 0.0 | 2 | .25 | ********** 2.0 | 2 | .25 | ********** 6.0 | 4 | .50 | ********************","title":"Histograms"},{"location":"monitors/#merging-of-monitors","text":"Tt is possible to merge the resulting statistics of multiple monitors val flmA = CategoryTimeline ( 1 ) val flmB = CategoryTimeline ( 2 ) // ... run simulation val mergedStats : EnumeratedDistribution < Int > = listOf ( flmA , flmB ). mergeStats () See MergeMonitorTests for more examples regarding the other monitor types.","title":"Merging of Monitors"},{"location":"monitors/#slicing-of-monitors","text":"Note : Slicing of monitors as in salabim is not yet supported. If needed please file a ticket . Use-cases for slicing are to get statistics on a monitor with respect to a given time period, most likely a subrun to get statistics on a monitor with respect to a recurring time period, like hour 0-1, hour 0-2, etc.","title":"Slicing of monitors"},{"location":"monitors/#summarizing-a-monitor","text":"Monitor.statistics() returns a 'frozen' monitor that can be used to store the results not depending on the current environment. This is particularly useful for persisting monitor statistics for later analysis.","title":"Summarizing a monitor"},{"location":"monitors/#visualization","text":"It is possible to render monitors with the following extension functions NumericStatisticMonitor . display () MetricTimeline . display () In particular multiple outputs are supported here by the underlying kravis visualization windows, which allows forward backward navigation (via the arrow buttons). See org.kalasim.examples.bank.resources.Bank3ClerksResources for an example where multiple visualizing are combined to inspect the internal state of the simulation. Note that, currently monitor visualization just works in retrospect, and it is not (yet) possible to view the progression while a simulation is still running.","title":"Visualization"},{"location":"resource/","text":"Resources Resources are a powerful way of process interaction. A resource has always a capacity (which can be zero and even negative). This capacity will be specified at time of creation, but can be changed later with r.capacity = newCapacity . Note that this may lead to requesting components to be honored if possible. There are two of types resources: Standard resources , where each claim is associated with a component (the claimer). It is not necessary that the claimed quantities are integer. Depletable resources , where only the claimed quantity is registered. This is most useful for dealing with levels, lengths, etc. Resources are declared with: val clerks = Resource ( \"clerks\" , capacity = 3 ) Any component can request from a resource in its process method . The user must not use request outside of a component's process definition. request has the effect that the component will check whether the requested quantity from a resource is available. It is possible to check for multiple availability of a certain quantity from several resources. Resources have a queue requesters containing all components trying to claim from the resource. In addition, there is a queue claimers containing all components claiming from the resource (not for anonymous resources). Both queues must not be modified but str useful for analysis. Notes request is not allowed for data components or main. If to be used for the current component (which will be nearly always the case), use yield (request(...)) . If the same resource is specified more that once, the quantities are summed. The requested quantity may exceed the current capacity of a resource. The parameter failed will be reset by a calling request or wait . Request Scope The most common usage pattern for resources is the request scope which requests a resource, executes some action, and finally releases the claimed resources request ( clerks ) { //1 hold ( 1 , description = \"doing something\" ) //2 } //3 In the example, kalasim will release the clerks automatically at the end of the request scope. When requesting from a single resource in a nested way, claims are merged. Unscoped Usage The user can omit the request scope (not recommended and mostly not needed), and release claimed resources with release . request ( clerks ) hold ( 1 , description = \"doing something\" ) release ( clerks ) Typically, this is only needed when releasing a defined quantity from a resource with c.release() , e.g. customer . release () // releases all claimed quantity from r customer . release ( 2 ) // release quantity 2 from r After a release, all other requesting components will be checked whether their claim can be honored. Examples Bank Office with Resources Car Wash Traffic Gas Station Quantity Some requests may have a capacity greater than 1. To request more than one unit from a resource, the user can use withQuantity : request ( clerks ) // request 1 from clerks request ( clerks withQuantity 2 ) // request 2 elements from clerks Request Priority As multiple components may request the same resource, it is important to prioritize requests. This is possible by providing a request priority request ( clerks withPriority IMPORTANT ) kalasim will order requests on a resource by priority. There are different predefined priorities which correspond the following sort-levels LOWEST (-20) LOW (-10) NORMAL (0) IMPORTANT (20) CRITICAL (20) The user can also create more fine-grained priorities with Priority(23) Multiple resources It is also possible to request for more resources at once. In the following examples, we request 1 quantity from clerks AND 2 quantities from assistance . request ( clerks withQuantity 1 , assistance withQuantity 2 ) To request alternative resources, the user can define the parameter oneOf=true , which will would result in requesting 1 quantity from clerks OR 2 quantities from assistance . Another method to query from a pool of resources are group requests. These are simply achieved by grouping resources in a List before requesting from it using oneOf=true . //// ResourceGroups.kts import org.kalasim.Component import org.kalasim.Resource val drMeier = Resource () val drSchreier = Resource () val doctors : List < Resource > = listOf ( drMeier , drSchreier ) object : Component () { override fun process () = sequence { request ( doctors , oneOf = true ) { hold ( 1 , \"first aid\" ) } // the patient needs brain surgery, only Dr Meier can do that request ( drMeier ) { hold ( 10 , \"brain surgery\" ) } } } Typical use cases are staff models, where certain colleagues have similar but not identical qualification. In case of the same qualification, a single resource with a capacity equal to the staff size, would be usually the better/correct solution. Activity Log Resources have a activities attribute that provides a history of scoped requests as a List<ResourceActivityEvent> r1 . activities . plot ( y = { resource . name }, yend = { resource . name }, x = { start }, xend = { end }, color = { activity }) . geomSegment ( size = 10.0 ) . yLabel ( \"Resource\" ) This visualization is also provided by a built-in display() extension for the activity log. There's also a notebook with a complete example. Timeline The timeline attribute of a resource reports the progression of all its major metrics. The timeline provides a changelog of a resource in terms of: capacity of the resource claimed capacity # requesters in the queue of the resource at a given time # claimers claiming from the resource at a given time For convenience also 2 inferrable attributes are also included: availability occupancy Technically, the timeline is a List<ResourceTimelineSegment> that covers the entire lifespan of the resource as step functions per metric. Example (from example notebook ) that illustrates how the timeline can be used to visualize some aspects of the resource utilization over time. r . timelime . filter { listOf ( ResourceMetric . Capacity , ResourceMetric . Claimed ). contains ( it . metric )} . plot ( x = { start }, y = { value } , color = { metric }) . geomStep () . facetWrap ( \"color\" , ncol = 1 , scales = FacetScales . free_y ) This visualization is also provided by a built-in display() extension for the timeline attribute. Monitors Resources have a number of monitors: claimers queueLength lengthOfStay requesters queueLength lengthOfStay claimedQuantity availableQuantity capacity occupancy (= claimed quantity / capacity) By default, all monitors are enabled. With r.printStatistics() the key statistics of these all monitors are printed. E.g. { \"availableQuantity\" : { \"duration\" : 3000 , \"min\" : 0 , \"max\" : 3 , \"mean\" : 0.115 , \"standard_deviation\" : 0.332 }, \"claimedQuantity\" : { \"duration\" : 3000 , \"min\" : 0 , \"max\" : 3 , \"mean\" : 2.885 , \"standard_deviation\" : 0.332 }, \"occupancy\" : { \"duration\" : 3000 , \"min\" : 0 , \"max\" : 1 , \"mean\" : 0.962 , \"standard_deviation\" : 0.111 }, \"name\" : \"clerks\" , \"requesterStats\" : { \"queue_length\" : { \"all\" : { \"duration\" : 3000 , \"min\" : 0 , \"max\" : 3 , \"mean\" : 0.564 , \"standard_deviation\" : 0.727 }, \"excl_zeros\" : { \"duration\" : 1283.1906989415463 , \"min\" : 1 , \"max\" : 3 , \"mean\" : 1.319 , \"standard_deviation\" : 0.49 } }, \"name\" : \"requesters of clerks\" , \"length_of_stay\" : { \"all\" : { \"entries\" : 290 , \"ninety_pct_quantile\" : 15.336764014133065 , \"median\" : 6.97 , \"mean\" : 5.771 , \"ninetyfive_pct_quantile\" : 17.9504616361896 , \"standard_deviation\" : 6.97 }, \"excl_zeros\" : { \"entries\" : 205 , \"ninety_pct_quantile\" : 17.074664209460025 , \"median\" : 7.014 , \"mean\" : 8.163 , \"ninetyfive_pct_quantile\" : 19.28443602612993 , \"standard_deviation\" : 7.014 } }, \"type\" : \"QueueStatistics\" }, \"type\" : \"ResourceStatistics\" , \"timestamp\" : 3000 , \"claimerStats\" : { \"queue_length\" : { \"all\" : { \"duration\" : 3000 , \"min\" : 0 , \"max\" : 3 , \"mean\" : 2.885 , \"standard_deviation\" : 0.332 }, \"excl_zeros\" : { \"duration\" : 3000 , \"min\" : 1 , \"max\" : 3 , \"mean\" : 2.885 , \"standard_deviation\" : 0.332 } }, \"name\" : \"claimers of clerks\" , \"length_of_stay\" : { \"all\" : { \"entries\" : 287 , \"ninety_pct_quantile\" : 30 , \"median\" : 0 , \"mean\" : 30 , \"ninetyfive_pct_quantile\" : 30 , \"standard_deviation\" : 0 }, \"excl_zeros\" : { \"entries\" : 287 , \"ninety_pct_quantile\" : 30 , \"median\" : 0 , \"mean\" : 30 , \"ninetyfive_pct_quantile\" : 30 , \"standard_deviation\" : 0 } }, \"type\" : \"QueueStatistics\" }, \"capacity\" : { \"duration\" : 3000 , \"min\" : 3 , \"max\" : 3 , \"mean\" : 3 , \"standard_deviation\" : 0 } } With r.printInfo() a summary of the contents of the queues can be printed. E.g.: { \"claimedQuantity\" : 3 , \"requestingComponents\" : [ { \"component\" : \"Customer.292\" , \"quantity\" : 1 }, { \"component\" : \"Customer.291\" , \"quantity\" : 1 } ], \"creationTime\" : 0 , \"name\" : \"clerks\" , \"claimedBy\" : [ { \"first\" : \"Customer.288\" , \"second\" : null }, { \"first\" : \"Customer.289\" , \"second\" : null }, { \"first\" : \"Customer.290\" , \"second\" : null } ], \"capacity\" : 3 } Querying of the capacity, claimed quantity, available quantity and occupancy can be done with: r.capacity , r.claimedQuantity , r.availableQuantity and r.occupancy . All quantities are tracked by corresponding level monitors to provide statistics. If the capacity of a resource is constant, which is very common, the mean occupancy can be found with: r.occupancyMonitor.statistics().mean When the capacity changes over time, it is recommended to use: occupancy = r.claimedQuanityMonitor.statistics().mean / r.capacityMonitor.statistics().mean() to obtain the mean occupancy. Note that the occupancy is set to 0 if the capacity of the resource is <= 0. Resource Selection There is a special mechanism to select resources dynamically. With selectResource() a resource can be selected from a list of resources using a policy. There are several policies provided: SHORTEST_QUEUE : The resource with the shortest queue, i.e. the least busy resource is selected. ROUND_ROBIN : Resources will be selected in a cyclical order. FIRST_AVAILABLE : The first available resource is selected. RANDOM : A resource is randomly selected. The *_AVAILABLE policies check for resource availability (i.e. whether the current capacity is sufficient to honor the requested quantity (defaulting to 1 ). Resources that do not meet this requirement will not be considered for selection. When using these policies, an error will be raised if all resources are unavailable. Warning With selectResource , a resource will be only selected. It won't actually request it. Example ////ResourceSelection.kts import org.kalasim.* import org.kalasim.ResourceSelectionPolicy.* createSimulation ( false ) { val doctors = List ( 3 ) { Resource () } class Patient : Component () { override fun process () = sequence { val requiredQuantity = 3 val selected = selectResource ( doctors , quantity = requiredQuantity , policy = SHORTEST_QUEUE ) request ( selected withQuantity requiredQuantity ) { hold ( 10 ) } } } ComponentGenerator ( exponential ( 1 )){ Patient ()} run ( 100 ) } An alternative more direct approach to achieve round-robin resource selection (e.g. for nested calls) could also be implemented ( example ) with an iterator. Depletable Resources For depletable (which are also referred to as anonymous ) resources, it may be not allowed to exceed the capacity and have a component wait for enough (claimed) capacity to be available. That may be accomplished by using a negative quantity in the Component.request() call. To create a depleteable resource we {done} val tank = DepletableResource ( capacity = 10 , initialLevel = 5 ) We can declare its maximum capacity and its initial fill level. The latter is optional and defaults to the capacity of the resource. In addition to the Resource attributs, depletable resources have the following attributes to streamline model building level - Indicates the current level of the resource isDepleted - Indicates if depletable resource is depleted (level==0) isFull - Indicates if depletable resource is at full capacity Alternatively, it possible to use the Component.put() method, where quantities of anonymous resources are negated. For symmetry reasons, kalasim also offers the Component.get() method, which is behaves exactly like Component.request() . The model below illustrates the use of get and put . See the Gas Station simulation for a living example. Pre-emptive Resources It is possible to specify that a resource is to be preemptive, by adding preemptive = true when the resource is created. If a component requests from a preemptive resource, it may bump component(s) that are claiming from the resource, provided these have a lower priority = higher value). If component is bumped, it releases the resource and is then activated, thus essentially stopping the current action (usually hold or passivate ). Therefore, a component claiming from a preemptive resource should check whether the component is bumped or still claiming at any point where they can be bumped. This can be done with the method Component.isClaiming(resource) which is true if the component is claiming from the resource, or the opposite (Component.isBumped) which is true is the component is not claiming from the resource. Examples Machine Shop","title":"Resources"},{"location":"resource/#resources","text":"Resources are a powerful way of process interaction. A resource has always a capacity (which can be zero and even negative). This capacity will be specified at time of creation, but can be changed later with r.capacity = newCapacity . Note that this may lead to requesting components to be honored if possible. There are two of types resources: Standard resources , where each claim is associated with a component (the claimer). It is not necessary that the claimed quantities are integer. Depletable resources , where only the claimed quantity is registered. This is most useful for dealing with levels, lengths, etc. Resources are declared with: val clerks = Resource ( \"clerks\" , capacity = 3 ) Any component can request from a resource in its process method . The user must not use request outside of a component's process definition. request has the effect that the component will check whether the requested quantity from a resource is available. It is possible to check for multiple availability of a certain quantity from several resources. Resources have a queue requesters containing all components trying to claim from the resource. In addition, there is a queue claimers containing all components claiming from the resource (not for anonymous resources). Both queues must not be modified but str useful for analysis. Notes request is not allowed for data components or main. If to be used for the current component (which will be nearly always the case), use yield (request(...)) . If the same resource is specified more that once, the quantities are summed. The requested quantity may exceed the current capacity of a resource. The parameter failed will be reset by a calling request or wait .","title":"Resources"},{"location":"resource/#request-scope","text":"The most common usage pattern for resources is the request scope which requests a resource, executes some action, and finally releases the claimed resources request ( clerks ) { //1 hold ( 1 , description = \"doing something\" ) //2 } //3 In the example, kalasim will release the clerks automatically at the end of the request scope. When requesting from a single resource in a nested way, claims are merged.","title":"Request Scope"},{"location":"resource/#unscoped-usage","text":"The user can omit the request scope (not recommended and mostly not needed), and release claimed resources with release . request ( clerks ) hold ( 1 , description = \"doing something\" ) release ( clerks ) Typically, this is only needed when releasing a defined quantity from a resource with c.release() , e.g. customer . release () // releases all claimed quantity from r customer . release ( 2 ) // release quantity 2 from r After a release, all other requesting components will be checked whether their claim can be honored.","title":"Unscoped Usage"},{"location":"resource/#examples","text":"Bank Office with Resources Car Wash Traffic Gas Station","title":"Examples"},{"location":"resource/#quantity","text":"Some requests may have a capacity greater than 1. To request more than one unit from a resource, the user can use withQuantity : request ( clerks ) // request 1 from clerks request ( clerks withQuantity 2 ) // request 2 elements from clerks","title":"Quantity"},{"location":"resource/#request-priority","text":"As multiple components may request the same resource, it is important to prioritize requests. This is possible by providing a request priority request ( clerks withPriority IMPORTANT ) kalasim will order requests on a resource by priority. There are different predefined priorities which correspond the following sort-levels LOWEST (-20) LOW (-10) NORMAL (0) IMPORTANT (20) CRITICAL (20) The user can also create more fine-grained priorities with Priority(23)","title":"Request Priority"},{"location":"resource/#multiple-resources","text":"It is also possible to request for more resources at once. In the following examples, we request 1 quantity from clerks AND 2 quantities from assistance . request ( clerks withQuantity 1 , assistance withQuantity 2 ) To request alternative resources, the user can define the parameter oneOf=true , which will would result in requesting 1 quantity from clerks OR 2 quantities from assistance . Another method to query from a pool of resources are group requests. These are simply achieved by grouping resources in a List before requesting from it using oneOf=true . //// ResourceGroups.kts import org.kalasim.Component import org.kalasim.Resource val drMeier = Resource () val drSchreier = Resource () val doctors : List < Resource > = listOf ( drMeier , drSchreier ) object : Component () { override fun process () = sequence { request ( doctors , oneOf = true ) { hold ( 1 , \"first aid\" ) } // the patient needs brain surgery, only Dr Meier can do that request ( drMeier ) { hold ( 10 , \"brain surgery\" ) } } } Typical use cases are staff models, where certain colleagues have similar but not identical qualification. In case of the same qualification, a single resource with a capacity equal to the staff size, would be usually the better/correct solution.","title":"Multiple resources"},{"location":"resource/#activity-log","text":"Resources have a activities attribute that provides a history of scoped requests as a List<ResourceActivityEvent> r1 . activities . plot ( y = { resource . name }, yend = { resource . name }, x = { start }, xend = { end }, color = { activity }) . geomSegment ( size = 10.0 ) . yLabel ( \"Resource\" ) This visualization is also provided by a built-in display() extension for the activity log. There's also a notebook with a complete example.","title":"Activity Log"},{"location":"resource/#timeline","text":"The timeline attribute of a resource reports the progression of all its major metrics. The timeline provides a changelog of a resource in terms of: capacity of the resource claimed capacity # requesters in the queue of the resource at a given time # claimers claiming from the resource at a given time For convenience also 2 inferrable attributes are also included: availability occupancy Technically, the timeline is a List<ResourceTimelineSegment> that covers the entire lifespan of the resource as step functions per metric. Example (from example notebook ) that illustrates how the timeline can be used to visualize some aspects of the resource utilization over time. r . timelime . filter { listOf ( ResourceMetric . Capacity , ResourceMetric . Claimed ). contains ( it . metric )} . plot ( x = { start }, y = { value } , color = { metric }) . geomStep () . facetWrap ( \"color\" , ncol = 1 , scales = FacetScales . free_y ) This visualization is also provided by a built-in display() extension for the timeline attribute.","title":"Timeline"},{"location":"resource/#monitors","text":"Resources have a number of monitors: claimers queueLength lengthOfStay requesters queueLength lengthOfStay claimedQuantity availableQuantity capacity occupancy (= claimed quantity / capacity) By default, all monitors are enabled. With r.printStatistics() the key statistics of these all monitors are printed. E.g. { \"availableQuantity\" : { \"duration\" : 3000 , \"min\" : 0 , \"max\" : 3 , \"mean\" : 0.115 , \"standard_deviation\" : 0.332 }, \"claimedQuantity\" : { \"duration\" : 3000 , \"min\" : 0 , \"max\" : 3 , \"mean\" : 2.885 , \"standard_deviation\" : 0.332 }, \"occupancy\" : { \"duration\" : 3000 , \"min\" : 0 , \"max\" : 1 , \"mean\" : 0.962 , \"standard_deviation\" : 0.111 }, \"name\" : \"clerks\" , \"requesterStats\" : { \"queue_length\" : { \"all\" : { \"duration\" : 3000 , \"min\" : 0 , \"max\" : 3 , \"mean\" : 0.564 , \"standard_deviation\" : 0.727 }, \"excl_zeros\" : { \"duration\" : 1283.1906989415463 , \"min\" : 1 , \"max\" : 3 , \"mean\" : 1.319 , \"standard_deviation\" : 0.49 } }, \"name\" : \"requesters of clerks\" , \"length_of_stay\" : { \"all\" : { \"entries\" : 290 , \"ninety_pct_quantile\" : 15.336764014133065 , \"median\" : 6.97 , \"mean\" : 5.771 , \"ninetyfive_pct_quantile\" : 17.9504616361896 , \"standard_deviation\" : 6.97 }, \"excl_zeros\" : { \"entries\" : 205 , \"ninety_pct_quantile\" : 17.074664209460025 , \"median\" : 7.014 , \"mean\" : 8.163 , \"ninetyfive_pct_quantile\" : 19.28443602612993 , \"standard_deviation\" : 7.014 } }, \"type\" : \"QueueStatistics\" }, \"type\" : \"ResourceStatistics\" , \"timestamp\" : 3000 , \"claimerStats\" : { \"queue_length\" : { \"all\" : { \"duration\" : 3000 , \"min\" : 0 , \"max\" : 3 , \"mean\" : 2.885 , \"standard_deviation\" : 0.332 }, \"excl_zeros\" : { \"duration\" : 3000 , \"min\" : 1 , \"max\" : 3 , \"mean\" : 2.885 , \"standard_deviation\" : 0.332 } }, \"name\" : \"claimers of clerks\" , \"length_of_stay\" : { \"all\" : { \"entries\" : 287 , \"ninety_pct_quantile\" : 30 , \"median\" : 0 , \"mean\" : 30 , \"ninetyfive_pct_quantile\" : 30 , \"standard_deviation\" : 0 }, \"excl_zeros\" : { \"entries\" : 287 , \"ninety_pct_quantile\" : 30 , \"median\" : 0 , \"mean\" : 30 , \"ninetyfive_pct_quantile\" : 30 , \"standard_deviation\" : 0 } }, \"type\" : \"QueueStatistics\" }, \"capacity\" : { \"duration\" : 3000 , \"min\" : 3 , \"max\" : 3 , \"mean\" : 3 , \"standard_deviation\" : 0 } } With r.printInfo() a summary of the contents of the queues can be printed. E.g.: { \"claimedQuantity\" : 3 , \"requestingComponents\" : [ { \"component\" : \"Customer.292\" , \"quantity\" : 1 }, { \"component\" : \"Customer.291\" , \"quantity\" : 1 } ], \"creationTime\" : 0 , \"name\" : \"clerks\" , \"claimedBy\" : [ { \"first\" : \"Customer.288\" , \"second\" : null }, { \"first\" : \"Customer.289\" , \"second\" : null }, { \"first\" : \"Customer.290\" , \"second\" : null } ], \"capacity\" : 3 } Querying of the capacity, claimed quantity, available quantity and occupancy can be done with: r.capacity , r.claimedQuantity , r.availableQuantity and r.occupancy . All quantities are tracked by corresponding level monitors to provide statistics. If the capacity of a resource is constant, which is very common, the mean occupancy can be found with: r.occupancyMonitor.statistics().mean When the capacity changes over time, it is recommended to use: occupancy = r.claimedQuanityMonitor.statistics().mean / r.capacityMonitor.statistics().mean() to obtain the mean occupancy. Note that the occupancy is set to 0 if the capacity of the resource is <= 0.","title":"Monitors"},{"location":"resource/#resource-selection","text":"There is a special mechanism to select resources dynamically. With selectResource() a resource can be selected from a list of resources using a policy. There are several policies provided: SHORTEST_QUEUE : The resource with the shortest queue, i.e. the least busy resource is selected. ROUND_ROBIN : Resources will be selected in a cyclical order. FIRST_AVAILABLE : The first available resource is selected. RANDOM : A resource is randomly selected. The *_AVAILABLE policies check for resource availability (i.e. whether the current capacity is sufficient to honor the requested quantity (defaulting to 1 ). Resources that do not meet this requirement will not be considered for selection. When using these policies, an error will be raised if all resources are unavailable. Warning With selectResource , a resource will be only selected. It won't actually request it. Example ////ResourceSelection.kts import org.kalasim.* import org.kalasim.ResourceSelectionPolicy.* createSimulation ( false ) { val doctors = List ( 3 ) { Resource () } class Patient : Component () { override fun process () = sequence { val requiredQuantity = 3 val selected = selectResource ( doctors , quantity = requiredQuantity , policy = SHORTEST_QUEUE ) request ( selected withQuantity requiredQuantity ) { hold ( 10 ) } } } ComponentGenerator ( exponential ( 1 )){ Patient ()} run ( 100 ) } An alternative more direct approach to achieve round-robin resource selection (e.g. for nested calls) could also be implemented ( example ) with an iterator.","title":"Resource Selection"},{"location":"resource/#depletable-resources","text":"For depletable (which are also referred to as anonymous ) resources, it may be not allowed to exceed the capacity and have a component wait for enough (claimed) capacity to be available. That may be accomplished by using a negative quantity in the Component.request() call. To create a depleteable resource we {done} val tank = DepletableResource ( capacity = 10 , initialLevel = 5 ) We can declare its maximum capacity and its initial fill level. The latter is optional and defaults to the capacity of the resource. In addition to the Resource attributs, depletable resources have the following attributes to streamline model building level - Indicates the current level of the resource isDepleted - Indicates if depletable resource is depleted (level==0) isFull - Indicates if depletable resource is at full capacity Alternatively, it possible to use the Component.put() method, where quantities of anonymous resources are negated. For symmetry reasons, kalasim also offers the Component.get() method, which is behaves exactly like Component.request() . The model below illustrates the use of get and put . See the Gas Station simulation for a living example.","title":"Depletable Resources"},{"location":"resource/#pre-emptive-resources","text":"It is possible to specify that a resource is to be preemptive, by adding preemptive = true when the resource is created. If a component requests from a preemptive resource, it may bump component(s) that are claiming from the resource, provided these have a lower priority = higher value). If component is bumped, it releases the resource and is then activated, thus essentially stopping the current action (usually hold or passivate ). Therefore, a component claiming from a preemptive resource should check whether the component is bumped or still claiming at any point where they can be bumped. This can be done with the method Component.isClaiming(resource) which is true if the component is claiming from the resource, or the opposite (Component.isBumped) which is true is the component is not claiming from the resource. Examples Machine Shop","title":"Pre-emptive Resources"},{"location":"setup/","text":"Installation kalasim requires Java11 or higher. Gradle To get started simply add it as a dependency: dependencies { implementation \"com.github.holgerbrandl:kalasim:0.7.3\" } Builds are hosted on maven-central supported by the great folks at sonatype . Jitpack Integration You can also use JitPack with Maven or Gradle to include the latest snapshot as a dependency in your project. repositories { maven { url 'https://jitpack.io' } } dependencies { implementation 'com.github.holgerbrandl:kalasim:-SNAPSHOT' } How to build it from sources? To build and install it into your local maven cache, simply clone the repo and run ./gradlew install","title":"Setup"},{"location":"setup/#installation","text":"kalasim requires Java11 or higher.","title":"Installation"},{"location":"setup/#gradle","text":"To get started simply add it as a dependency: dependencies { implementation \"com.github.holgerbrandl:kalasim:0.7.3\" } Builds are hosted on maven-central supported by the great folks at sonatype .","title":"Gradle"},{"location":"setup/#jitpack-integration","text":"You can also use JitPack with Maven or Gradle to include the latest snapshot as a dependency in your project. repositories { maven { url 'https://jitpack.io' } } dependencies { implementation 'com.github.holgerbrandl:kalasim:-SNAPSHOT' }","title":"Jitpack Integration"},{"location":"setup/#how-to-build-it-from-sources","text":"To build and install it into your local maven cache, simply clone the repo and run ./gradlew install","title":"How to build it from sources?"},{"location":"state/","text":"State States provide a powerful tool for process interaction. A state will have a value at any given time. In its simplest form a component can wait() for a specific value of a state. Once that value is reached, the component will be resumed. Examples Traffic Bank Office with 1 clerk Bank Office With Balking And Reneging Usage New States are defined as val doorOpen = State(false) . The initial value is false , meaning the door is closed. Now we can say : doorOpen . value = true to open the door. If we want a person to wait for an open door, we could say : wait ( doorOpen , true ) The person's process definition will be suspended until the door is open. We can obtain the current value (e.g. for logging) with: print ( \"\"\"door is ${ if ( doorOpen . value ) \" open \" else \" closed \" } \"\"\" ) The value of a state is automatically monitored in the State<T>.valueMonitor level monitor. All components waiting for a state are tracked in a (internal) queue, that can be obtained with doorOpen.waiters . If we just want at most one person to enter, we can use trigger() (which is a simple convenience wrapper around wait) with doorOpen.trigger(true, max=1) . The following will happen: Temporarily change the state to the provided value, Reschedule max components (or less if there are fewer/no waiters ) for immediate process continuation, and finally restore the previous state value Type Support States support generics, so we could equally well use any other type to model the value. For example, a traffic light could be modelled with a String state: // initially the traffic light is red val light = State(\"red\") ... // toggle its value to green light.value = \"green\" Or define a int/float state : val level = State(0.0) level.value += 10 Since State<T> is a generic type, the compiler will reject invalid level associations such as level.value = \"red\" This won't compile because the type of level is Double . Metrics States have a number of metrics endpoints: valueMonitor tracks state changes over time queueLength tracks the queue length level across time lengthOfStay tracks the length of stay in the queue over time Process interaction with wait() A component can wait() for a state to get a certain value. In its most simple form this is done with wait ( doorOpen , true ) Once the doorOpen state is true , the component will be scheduled for process continuation. As with request it is possible to set a timeout with failAt or failDelay : wait ( dooropen , true , failDelay = 10.0 ) if ( failed ) print ( \"impatient ...\" ) In this example, the process will wait at max 10 ticks. If the state predicate was not met until then, the failed flag will be set and be consumed by the user. There are two ways to test for a value Value testing Predicate testing Value Testing It is possible to test for a certain value: wait ( light , \"green\" ) Or more states at once: wait ( light turns \"green\" , light turns \"yellow\" ) where the wait is honored as soon is light is green OR yellow . It is also possible to wait for all conditions to be satisfied, by adding all=true : wait ( light turns \"green\" , engineRunning turns true , all = true ) Here, the wait is honored as soon as light is green AND the engine is running. Predicate testing This is a more complicated but also more versatile way of specifying the honor-condition. In that case, a predicate function (T) -> Boolean must be provided required to specify the condition. Example 1 wait ( StateRequest ( State ( \"foo\" )) { listOf ( \"bar\" , \"test\" ). contains ( it ) }) The wait is honored if the String State becomes either bar or test . Example 2 wait ( StateRequest ( State ( 3.0 )) { it * 3 < 42 }) In this last example the wait is honored as soon as the value fulfils it*3 < 42 .","title":"States"},{"location":"state/#state","text":"States provide a powerful tool for process interaction. A state will have a value at any given time. In its simplest form a component can wait() for a specific value of a state. Once that value is reached, the component will be resumed.","title":"State"},{"location":"state/#examples","text":"Traffic Bank Office with 1 clerk Bank Office With Balking And Reneging","title":"Examples"},{"location":"state/#usage","text":"New States are defined as val doorOpen = State(false) . The initial value is false , meaning the door is closed. Now we can say : doorOpen . value = true to open the door. If we want a person to wait for an open door, we could say : wait ( doorOpen , true ) The person's process definition will be suspended until the door is open. We can obtain the current value (e.g. for logging) with: print ( \"\"\"door is ${ if ( doorOpen . value ) \" open \" else \" closed \" } \"\"\" ) The value of a state is automatically monitored in the State<T>.valueMonitor level monitor. All components waiting for a state are tracked in a (internal) queue, that can be obtained with doorOpen.waiters . If we just want at most one person to enter, we can use trigger() (which is a simple convenience wrapper around wait) with doorOpen.trigger(true, max=1) . The following will happen: Temporarily change the state to the provided value, Reschedule max components (or less if there are fewer/no waiters ) for immediate process continuation, and finally restore the previous state value","title":"Usage"},{"location":"state/#type-support","text":"States support generics, so we could equally well use any other type to model the value. For example, a traffic light could be modelled with a String state: // initially the traffic light is red val light = State(\"red\") ... // toggle its value to green light.value = \"green\" Or define a int/float state : val level = State(0.0) level.value += 10 Since State<T> is a generic type, the compiler will reject invalid level associations such as level.value = \"red\" This won't compile because the type of level is Double .","title":"Type Support"},{"location":"state/#metrics","text":"States have a number of metrics endpoints: valueMonitor tracks state changes over time queueLength tracks the queue length level across time lengthOfStay tracks the length of stay in the queue over time","title":"Metrics"},{"location":"state/#process-interaction-with-wait","text":"A component can wait() for a state to get a certain value. In its most simple form this is done with wait ( doorOpen , true ) Once the doorOpen state is true , the component will be scheduled for process continuation. As with request it is possible to set a timeout with failAt or failDelay : wait ( dooropen , true , failDelay = 10.0 ) if ( failed ) print ( \"impatient ...\" ) In this example, the process will wait at max 10 ticks. If the state predicate was not met until then, the failed flag will be set and be consumed by the user. There are two ways to test for a value Value testing Predicate testing","title":"Process interaction with wait()"},{"location":"state/#value-testing","text":"It is possible to test for a certain value: wait ( light , \"green\" ) Or more states at once: wait ( light turns \"green\" , light turns \"yellow\" ) where the wait is honored as soon is light is green OR yellow . It is also possible to wait for all conditions to be satisfied, by adding all=true : wait ( light turns \"green\" , engineRunning turns true , all = true ) Here, the wait is honored as soon as light is green AND the engine is running.","title":"Value Testing"},{"location":"state/#predicate-testing","text":"This is a more complicated but also more versatile way of specifying the honor-condition. In that case, a predicate function (T) -> Boolean must be provided required to specify the condition.","title":"Predicate testing"},{"location":"state/#example-1","text":"wait ( StateRequest ( State ( \"foo\" )) { listOf ( \"bar\" , \"test\" ). contains ( it ) }) The wait is honored if the String State becomes either bar or test .","title":"Example 1"},{"location":"state/#example-2","text":"wait ( StateRequest ( State ( 3.0 )) { it * 3 < 42 }) In this last example the wait is honored as soon as the value fulfils it*3 < 42 .","title":"Example 2"},{"location":"theory/","text":"Simulation Theory As defined by Shannon (1975), a simulation is the process of designing a model of a real system and conducting experiments with this model for the purpose either of understanding the behavior of the system or of evaluating various strategies (within the limits imposed by a criterion or a set of criteria) for the operation of the system. What is discrete event simulation? A discrete event simulation (DES) is a tool that allows studying the dynamic behavior of stochastic, dynamic and discretely evolving systems such as Factories Ports & Airports Traffic Supply chains & Logistics Controlling In fact, every process that is founded on discrete state changes is suitable to be simulated with a discrete event simulation such as kalasim . As described by Ucar, 2019 , the discrete nature of a given system arises as soon as its behavior can be described in terms of events, which is the most fundamental concept in DES. An event is an instantaneous occurrence that may change the state of the system, while, between events, all the state variables remain. There are several main DES paradigms. In activity-oriented DES the simulation clock advances in fixed time increments and all simulation entities are scanned and possibly reevaluated. Clearly, simulation performance degrades quickly with smaller increments and increasingly complex models. In event-oriented DES is built around a list of scheduled events ordered by future execution time. During simulation, the these events are processed seqeuentially to update the state of the model. Finally, process-oriented DES refines the event-oriented approach by defining a vocabulary of interactions to describe the interplay between simulation entities. This vocabulary is used by the modeler to define the component life-cycle processes of each simulation entity. Applications of discrete event simulation Depending on the system in question, DES and kalasim in particular can provide insights into the process efficiency, risks or effectiveness. In addition, it allows assessing alternative what-if scenarios. Very often planning is all about estimating the effect of changes to a system. such as more/fewer driver, more/fewer machines, more/less repair cycles, more/fewer cargo trolleys. Typical applications of discrete event simulations are Production planning (such as bottleneck analysis) Dimensioning (How many drivers are needed? Number of servers?) Process automation & visualization Digital twin development Project management For in-depth primers about simulation see here or Ucar, 2019 . Other Simulation Tools There are too many to be listed. In generally there are graphical tools and APIs . Graphical tools, such as AnyLogic excel by providing a flat learning curve, great visuals but often lack interfaces for extensibility or automation. APIs are usually much more flexible but often lack an intuitive approach to actually build simulations. Out of the great number of APIs, we pinpoint just those projects/products which served as source of inspiration when developing kalasim .","title":"Theory"},{"location":"theory/#simulation-theory","text":"As defined by Shannon (1975), a simulation is the process of designing a model of a real system and conducting experiments with this model for the purpose either of understanding the behavior of the system or of evaluating various strategies (within the limits imposed by a criterion or a set of criteria) for the operation of the system.","title":"Simulation Theory"},{"location":"theory/#what-is-discrete-event-simulation","text":"A discrete event simulation (DES) is a tool that allows studying the dynamic behavior of stochastic, dynamic and discretely evolving systems such as Factories Ports & Airports Traffic Supply chains & Logistics Controlling In fact, every process that is founded on discrete state changes is suitable to be simulated with a discrete event simulation such as kalasim . As described by Ucar, 2019 , the discrete nature of a given system arises as soon as its behavior can be described in terms of events, which is the most fundamental concept in DES. An event is an instantaneous occurrence that may change the state of the system, while, between events, all the state variables remain. There are several main DES paradigms. In activity-oriented DES the simulation clock advances in fixed time increments and all simulation entities are scanned and possibly reevaluated. Clearly, simulation performance degrades quickly with smaller increments and increasingly complex models. In event-oriented DES is built around a list of scheduled events ordered by future execution time. During simulation, the these events are processed seqeuentially to update the state of the model. Finally, process-oriented DES refines the event-oriented approach by defining a vocabulary of interactions to describe the interplay between simulation entities. This vocabulary is used by the modeler to define the component life-cycle processes of each simulation entity.","title":"What is discrete event simulation?"},{"location":"theory/#applications-of-discrete-event-simulation","text":"Depending on the system in question, DES and kalasim in particular can provide insights into the process efficiency, risks or effectiveness. In addition, it allows assessing alternative what-if scenarios. Very often planning is all about estimating the effect of changes to a system. such as more/fewer driver, more/fewer machines, more/less repair cycles, more/fewer cargo trolleys. Typical applications of discrete event simulations are Production planning (such as bottleneck analysis) Dimensioning (How many drivers are needed? Number of servers?) Process automation & visualization Digital twin development Project management For in-depth primers about simulation see here or Ucar, 2019 .","title":"Applications of discrete event simulation"},{"location":"theory/#other-simulation-tools","text":"There are too many to be listed. In generally there are graphical tools and APIs . Graphical tools, such as AnyLogic excel by providing a flat learning curve, great visuals but often lack interfaces for extensibility or automation. APIs are usually much more flexible but often lack an intuitive approach to actually build simulations. Out of the great number of APIs, we pinpoint just those projects/products which served as source of inspiration when developing kalasim .","title":"Other Simulation Tools"},{"location":"visualization/","text":"Visualization There are two type of visualizations Statistical plots to inspect distributions, trends and outliers. That's what described in this chapter Process rendering to actually show simulation entities, their state or position changes on a 2D (or even 3D) grid as rendered movie. This may also involve interactive controls to adjust simulation parameters. Such functionality is planned but not yet implemented in kalasim Examples * Movie Theater Built-in Visualizations Currently, the following extensions for distribution analysis are supported Components Monitors CategoryTimeline<T>.display() provides a segment chart of the level FrequencyTable<T>.display() provides a barchart of the frequencies of the different values NumericStatisticMonitor.display() provides histogram of the underlying distribution MetricTimeline.display() provides a line chart with time on the x and the value on y Resources r.activiities to show the activities as segments timeline r.timeline to show the resource utilization and queuing status All monitor related plots from above Component Queue All monitor related plots from above For monitors , see corresponding section Framework Support By default, kalasim supports 2 pluggable visualization backends. Currently kravis and lets-plot are supported. Since we may not be able to support all visualizations in both frontends, the user can simply toggle the frontend by package import: // simply toggle backend by package import import org.kalasim.plot.letsplot.display // or //import org.kalasim.plot.kravis.display MM1Queue (). apply { run ( 100 ) server . claimedMonitor . display () } Kravis kalasim integrates nicely with kravis to visualize monitor data. For examples see src/test/kotlin/org/kalasim/analytics/KravisVis.kt . Note To visualize data with kravis, R must be installed on the system. See here ) for details. LetsPlot lets-plot is another very modern visualization library that renders within the JVM and thus does not have any external dependencies. Similar to kravis it mimics the API of ggplot2 .","title":"Visualization"},{"location":"visualization/#visualization","text":"There are two type of visualizations Statistical plots to inspect distributions, trends and outliers. That's what described in this chapter Process rendering to actually show simulation entities, their state or position changes on a 2D (or even 3D) grid as rendered movie. This may also involve interactive controls to adjust simulation parameters. Such functionality is planned but not yet implemented in kalasim Examples * Movie Theater","title":"Visualization"},{"location":"visualization/#built-in-visualizations","text":"Currently, the following extensions for distribution analysis are supported Components Monitors CategoryTimeline<T>.display() provides a segment chart of the level FrequencyTable<T>.display() provides a barchart of the frequencies of the different values NumericStatisticMonitor.display() provides histogram of the underlying distribution MetricTimeline.display() provides a line chart with time on the x and the value on y Resources r.activiities to show the activities as segments timeline r.timeline to show the resource utilization and queuing status All monitor related plots from above Component Queue All monitor related plots from above For monitors , see corresponding section","title":"Built-in Visualizations"},{"location":"visualization/#framework-support","text":"By default, kalasim supports 2 pluggable visualization backends. Currently kravis and lets-plot are supported. Since we may not be able to support all visualizations in both frontends, the user can simply toggle the frontend by package import: // simply toggle backend by package import import org.kalasim.plot.letsplot.display // or //import org.kalasim.plot.kravis.display MM1Queue (). apply { run ( 100 ) server . claimedMonitor . display () }","title":"Framework Support"},{"location":"visualization/#kravis","text":"kalasim integrates nicely with kravis to visualize monitor data. For examples see src/test/kotlin/org/kalasim/analytics/KravisVis.kt . Note To visualize data with kravis, R must be installed on the system. See here ) for details.","title":"Kravis"},{"location":"visualization/#letsplot","text":"lets-plot is another very modern visualization library that renders within the JVM and thus does not have any external dependencies. Similar to kravis it mimics the API of ggplot2 .","title":"LetsPlot"},{"location":"articles/2021-11-27-kalasim-v07/","text":"After quite some months of exploration, API refinements, countless simulations, and some literature research, we present with great pleasure the next milestone release of kalasim ! kalasim v0.7 is not just for engineers, but for process analysts and industrial engineers who need to go beyond the limitations of existing simulation tools to model and optimize their business-critical use-cases. So, we deliberately took some time with this release to gather and analyze feedback from our users. With this milestone release, we have stabilized the core API considerably, improved its performance dramatically while adding new features all over the place. New Features Major enhancements in this release are Added processRepeated to streamline modelling of reiterating processes Reworked event & metrics logging API for better configurability and performance Introduced ComponentList to provide metrics-enhanced collection similar to the existing ComponentQueue Implemented ticks metrics monitor to streamline simulation monitoring Added new timeline and activity log attributes to resources for streamlined utilization analytics Extended display() support API on all major components and their collections (including Resource , Component or List<Component> , MetricTimeline ) Enabled simplified simulation parallelism by changing the dependency context registry to become thread-local Dramatically improved simulation performance to scale at ease to thousands of simulation entities See kalasim 's changlog for a complete list of technical changes in the v0.7 milestone release Documentation Improvements We've rewritten a large part of the documentation for better readability. In particular, we've focussed on resources and components , which are the key elements of every business process model. A new chapter about collections was added, and the numerous advanced topics were worked out to cover more aspects of the product in much more detail. Several new examples were added including the famous Bridge Games . The ATM was rebuilt using a jupyter-notebook example to better illustrate parallelization and the new visualization support API . Finally, we started a new larger scale example simulation to model the interplay of processes in an emergency room . Acknowledgments Different individuals and organizations made this milestone release possible. Most importantly, we'd like to thank SYSTEMA GmbH for supporting the project. Special thanks go to Ilya Muradyan and Igor Alshannikov from JetBrains for their patience with us and their wonderful support with Kotlin data-science tooling. We like to thank Arnaud Giuliani for providing great koin support and guidance, which is the basement on which we managed to build kalasim . Finally, we'd like to thank the wonderful folks at CASUS for providing us the opportunity to introduce kalasim to a great simulation experts panel. Next steps We're having a packed feature roadmap. On the top of our roadmap are the following ideas Environment snapshotting & branching: This feature will dramatically ease distributed simulations, prepare for new types of AI connectivity, and will enable confidence bands for projects after user-defined branching events Environment merging: We strive to enable algebraic composability of simulation environments Better examples: Existing examples are intentionally kept small to illustrate the API. Next, we plan to release some large simulations with thousands of simulation entities, along with protocols on how to analyze dynamics in such systems Adopt new Kotlin v1.6 language features such as the new duration API, simplified suspend method semantics, and builder inference improvements Please note, that the kalasim APIs will be subject to breaking changes until a very distant major release. If you think that kalasim is missing some important feature, please just let us know .","title":"Kalasim v0.7"},{"location":"articles/2021-11-27-kalasim-v07/#new-features","text":"Major enhancements in this release are Added processRepeated to streamline modelling of reiterating processes Reworked event & metrics logging API for better configurability and performance Introduced ComponentList to provide metrics-enhanced collection similar to the existing ComponentQueue Implemented ticks metrics monitor to streamline simulation monitoring Added new timeline and activity log attributes to resources for streamlined utilization analytics Extended display() support API on all major components and their collections (including Resource , Component or List<Component> , MetricTimeline ) Enabled simplified simulation parallelism by changing the dependency context registry to become thread-local Dramatically improved simulation performance to scale at ease to thousands of simulation entities See kalasim 's changlog for a complete list of technical changes in the v0.7 milestone release","title":"New Features"},{"location":"articles/2021-11-27-kalasim-v07/#documentation-improvements","text":"We've rewritten a large part of the documentation for better readability. In particular, we've focussed on resources and components , which are the key elements of every business process model. A new chapter about collections was added, and the numerous advanced topics were worked out to cover more aspects of the product in much more detail. Several new examples were added including the famous Bridge Games . The ATM was rebuilt using a jupyter-notebook example to better illustrate parallelization and the new visualization support API . Finally, we started a new larger scale example simulation to model the interplay of processes in an emergency room .","title":"Documentation Improvements"},{"location":"articles/2021-11-27-kalasim-v07/#acknowledgments","text":"Different individuals and organizations made this milestone release possible. Most importantly, we'd like to thank SYSTEMA GmbH for supporting the project. Special thanks go to Ilya Muradyan and Igor Alshannikov from JetBrains for their patience with us and their wonderful support with Kotlin data-science tooling. We like to thank Arnaud Giuliani for providing great koin support and guidance, which is the basement on which we managed to build kalasim . Finally, we'd like to thank the wonderful folks at CASUS for providing us the opportunity to introduce kalasim to a great simulation experts panel.","title":"Acknowledgments"},{"location":"articles/2021-11-27-kalasim-v07/#next-steps","text":"We're having a packed feature roadmap. On the top of our roadmap are the following ideas Environment snapshotting & branching: This feature will dramatically ease distributed simulations, prepare for new types of AI connectivity, and will enable confidence bands for projects after user-defined branching events Environment merging: We strive to enable algebraic composability of simulation environments Better examples: Existing examples are intentionally kept small to illustrate the API. Next, we plan to release some large simulations with thousands of simulation entities, along with protocols on how to analyze dynamics in such systems Adopt new Kotlin v1.6 language features such as the new duration API, simplified suspend method semantics, and builder inference improvements Please note, that the kalasim APIs will be subject to breaking changes until a very distant major release. If you think that kalasim is missing some important feature, please just let us know .","title":"Next steps"},{"location":"articles/articles/","text":"Articles News, articles, and tutorials centering simulation best practices, success stories from industries, and technical deep dives. We've just started this section, so please be a bit patient in here :-)","title":"Overview"},{"location":"articles/articles/#articles","text":"News, articles, and tutorials centering simulation best practices, success stories from industries, and technical deep dives. We've just started this section, so please be a bit patient in here :-)","title":"Articles"},{"location":"examples/atm_queue/","text":"Simple Queue Model Let's explore the expressiveness of kalasim s process description using a traditional queuing example, the M/M/1 . This Kendall's notation describes a single server - here a ATM - with exponentially distributed arrivals, exponential service time and an infinte queue. The basic parameters of the system are \u03bb - people arrival rate at the ATM \u00b5 - money withdrawal rate If \u03bb/\u00b5 > 1, the queue is referred to as unstable since there are more arrivals than the ATM can handle. The queue will grow indefinitely. Let's start simply. First, we work out the basic model without much code reusability in mind. The ATM example is inspired from the simmer paper Ucar et al. 2019 . val sim = createSimulation { val lambda = 1.5 val mu = 1.0 val rho = lambda / mu println ( \"rho is ${ rho } . With rho>1 the system would be unstable, \" + \"because there are more arrivals then the atm can serve.\" ) val atm = Resource ( \"atm\" , 1 ) class Customer : Component () { val ed = exponential ( mu ) override fun process () = sequence { request ( atm ) hold ( ed . sample ()) release ( atm ) } } ComponentGenerator ( iat = exponential ( lambda )) { Customer () } run ( 2000 ) atm . occupancyTimeline . display () atm . requesters . queueLengthMonitor . display () atm . requesters . lengthOfStayMonitor . display () println ( \"\\nqueue statistics: ${ atm . requesters . lengthOfStayMonitor . statistics () } \" ) } rho is 1.5. With rho>1 the system would be unstable, because there are more arrivals then the atm can serve. queue statistics: { \"entries\": 1312, \"median\": 3.268, \"mean\": 2.061, \"ninety_pct_quantile\": 6.321, \"standard_deviation\": 3.268, \"ninetyfive_pct_quantile\": 9.091 } Simple WhatIf To explore the impact of lambda and mu on these statistics, we rework the example to become a bit more generic. class AtmCustomer ( val mu : Double , val atm : Resource , koin : Koin = DependencyContext . get () ) : Component ( koin = koin ) { val ed = exponential ( mu ) override fun process () = sequence { request ( atm ) hold ( ed . sample ()) release ( atm ) } } class AtmQueue ( val lambda : Double , val mu : Double ) : Environment () { val atm = dependency { Resource ( \"atm\" , 1 ) } init { ComponentGenerator ( iat = exponential ( lambda )) { AtmCustomer ( mu , atm , koin = getKoin ()) } } } Then, we evaluate a parameter grid. // build parameter grid val lambdas = ( 1. . 20 ). map { 0.25 }. cumSum () val mus = ( 1. . 20 ). map { 0.25 }. cumSum () // run 100x times val atms = cartesianProduct ( lambdas , mus ). map { ( lambda , mu ) -> AtmQueue ( lambda , mu ). apply { run ( 100 ) } } We now extract the ATM parameters along with he mean queue length of each ATM instance into a data-frame. atms . map { it to it . get < Resource > (). statistics . requesters . lengthStats . mean !! . roundAny ( 2 ) }. toList () . asDataFrame () . unfold < AtmQueue > ( \"first\" , listOf ( \"mu\" , \"lambda\" ), keep = false ) . rename ( \"second\" to \"mean_queue_length\" ) mean_queue_length lambda mu 8.25 0.25 0.25 113.83 0.25 0.5 149.73 0.25 0.75 172.69 0.25 1.0 178.59 0.25 1.25 206.61 0.25 1.5 188.26 0.25 1.75 205.89 0.25 2.0 209.68 0.25 2.25 210.42 0.25 2.5 ... with 390 more rows. Shape: 400 x 3. Parallel WhatIf Very often, simulation models are complex, so running different simulations in parellel allows to minimize overall execution time First, we build a number of sims (as Sequence ) and work them out in parallel using kotlin coroutines. val atms = cartesianProduct ( lambdas , mus ). asIterable (). map { ( lambda , mu ) -> // instantiate sequentially to simplify dependency injection AtmQueue ( lambda , mu ) }. toList () // define parallelization helper to run in parallel // https://stackoverflow.com/questions/34697828/parallel-operations|-on-kotlin-collections fun < A , B > Iterable < A > . pmap ( f : suspend ( A ) -> B ): List < B > = runBlocking { map { async ( newFixedThreadPoolContext ( 4 , \"\" )) { f ( it ) } }. map { it . await () } } // simulate in parallel atms . pmap { it . run ( 100 ) }. forEach {} // supppress the output Something really cool has just happened. We have run as many simulations in parallel as there are cores on this computer. Next, we can summarize our findings by visualizing the results in usin a heatmap. // extract stats and visualize val meanQLength = atms . map { it to it . get < Resource > (). statistics . requesters . lengthStats . mean !! } meanQLength . plot ( x = { first . lambda }, y = { first . mu }, fill = { second }) . geomTile () . title ( \"Mean ATM Queue Length vs Labmda and Mu\" ) . xLabel ( \"Labmda\" ). yLabel ( \"Mu\" ) Conclusion In this example we have explored a simple simulation model. In in fact we have not built just a single model, but instead we have modelled a range of ATMs with differeing settings to better understand the dynamics of the process at hand. For complete sources, also see the jupyter notebook or plain kotlin sources . Feel welcome to get in touch for support, suggestions, and questions.","title":"ATM Queue"},{"location":"examples/atm_queue/#simple-queue-model","text":"Let's explore the expressiveness of kalasim s process description using a traditional queuing example, the M/M/1 . This Kendall's notation describes a single server - here a ATM - with exponentially distributed arrivals, exponential service time and an infinte queue. The basic parameters of the system are \u03bb - people arrival rate at the ATM \u00b5 - money withdrawal rate If \u03bb/\u00b5 > 1, the queue is referred to as unstable since there are more arrivals than the ATM can handle. The queue will grow indefinitely. Let's start simply. First, we work out the basic model without much code reusability in mind. The ATM example is inspired from the simmer paper Ucar et al. 2019 . val sim = createSimulation { val lambda = 1.5 val mu = 1.0 val rho = lambda / mu println ( \"rho is ${ rho } . With rho>1 the system would be unstable, \" + \"because there are more arrivals then the atm can serve.\" ) val atm = Resource ( \"atm\" , 1 ) class Customer : Component () { val ed = exponential ( mu ) override fun process () = sequence { request ( atm ) hold ( ed . sample ()) release ( atm ) } } ComponentGenerator ( iat = exponential ( lambda )) { Customer () } run ( 2000 ) atm . occupancyTimeline . display () atm . requesters . queueLengthMonitor . display () atm . requesters . lengthOfStayMonitor . display () println ( \"\\nqueue statistics: ${ atm . requesters . lengthOfStayMonitor . statistics () } \" ) } rho is 1.5. With rho>1 the system would be unstable, because there are more arrivals then the atm can serve. queue statistics: { \"entries\": 1312, \"median\": 3.268, \"mean\": 2.061, \"ninety_pct_quantile\": 6.321, \"standard_deviation\": 3.268, \"ninetyfive_pct_quantile\": 9.091 }","title":"Simple Queue Model"},{"location":"examples/atm_queue/#simple-whatif","text":"To explore the impact of lambda and mu on these statistics, we rework the example to become a bit more generic. class AtmCustomer ( val mu : Double , val atm : Resource , koin : Koin = DependencyContext . get () ) : Component ( koin = koin ) { val ed = exponential ( mu ) override fun process () = sequence { request ( atm ) hold ( ed . sample ()) release ( atm ) } } class AtmQueue ( val lambda : Double , val mu : Double ) : Environment () { val atm = dependency { Resource ( \"atm\" , 1 ) } init { ComponentGenerator ( iat = exponential ( lambda )) { AtmCustomer ( mu , atm , koin = getKoin ()) } } } Then, we evaluate a parameter grid. // build parameter grid val lambdas = ( 1. . 20 ). map { 0.25 }. cumSum () val mus = ( 1. . 20 ). map { 0.25 }. cumSum () // run 100x times val atms = cartesianProduct ( lambdas , mus ). map { ( lambda , mu ) -> AtmQueue ( lambda , mu ). apply { run ( 100 ) } } We now extract the ATM parameters along with he mean queue length of each ATM instance into a data-frame. atms . map { it to it . get < Resource > (). statistics . requesters . lengthStats . mean !! . roundAny ( 2 ) }. toList () . asDataFrame () . unfold < AtmQueue > ( \"first\" , listOf ( \"mu\" , \"lambda\" ), keep = false ) . rename ( \"second\" to \"mean_queue_length\" ) mean_queue_length lambda mu 8.25 0.25 0.25 113.83 0.25 0.5 149.73 0.25 0.75 172.69 0.25 1.0 178.59 0.25 1.25 206.61 0.25 1.5 188.26 0.25 1.75 205.89 0.25 2.0 209.68 0.25 2.25 210.42 0.25 2.5 ... with 390 more rows. Shape: 400 x 3.","title":"Simple WhatIf"},{"location":"examples/atm_queue/#parallel-whatif","text":"Very often, simulation models are complex, so running different simulations in parellel allows to minimize overall execution time First, we build a number of sims (as Sequence ) and work them out in parallel using kotlin coroutines. val atms = cartesianProduct ( lambdas , mus ). asIterable (). map { ( lambda , mu ) -> // instantiate sequentially to simplify dependency injection AtmQueue ( lambda , mu ) }. toList () // define parallelization helper to run in parallel // https://stackoverflow.com/questions/34697828/parallel-operations|-on-kotlin-collections fun < A , B > Iterable < A > . pmap ( f : suspend ( A ) -> B ): List < B > = runBlocking { map { async ( newFixedThreadPoolContext ( 4 , \"\" )) { f ( it ) } }. map { it . await () } } // simulate in parallel atms . pmap { it . run ( 100 ) }. forEach {} // supppress the output Something really cool has just happened. We have run as many simulations in parallel as there are cores on this computer. Next, we can summarize our findings by visualizing the results in usin a heatmap. // extract stats and visualize val meanQLength = atms . map { it to it . get < Resource > (). statistics . requesters . lengthStats . mean !! } meanQLength . plot ( x = { first . lambda }, y = { first . mu }, fill = { second }) . geomTile () . title ( \"Mean ATM Queue Length vs Labmda and Mu\" ) . xLabel ( \"Labmda\" ). yLabel ( \"Mu\" )","title":"Parallel WhatIf"},{"location":"examples/atm_queue/#conclusion","text":"In this example we have explored a simple simulation model. In in fact we have not built just a single model, but instead we have modelled a range of ATMs with differeing settings to better understand the dynamics of the process at hand. For complete sources, also see the jupyter notebook or plain kotlin sources . Feel welcome to get in touch for support, suggestions, and questions.","title":"Conclusion"},{"location":"examples/bank_office/","text":"Queue problems are common-place application of discrete event simulation . Often there are multiple solutions for a model. Here we model similar problems - a customer queue - differently using resources, states and queues in various configurations and interaction patterns. Simple Bank Office (1 clerk) Lets start with a bank office where customers are arriving in a bank, where there is one clerk. This clerk handles the customers in a first in first out (FIFO) order. We see the following processes: The customer generator that creates the customers, with an inter-arrival time of uniform(5,15) The customers The clerk, which serves the customers in a constant time of 30 (overloaded and non steady state system) We need a queue for the customers to wait for service. The model code is: ////Bank1clerk.kt package org.kalasim.examples.bank.oneclerk import org.kalasim.* import org.kalasim.plot.kravis.canDisplay import org.kalasim.plot.kravis.display import org.koin.core.component.inject class Customer ( val waitingLine : ComponentQueue < Customer > , val clerk : Clerk ) : Component () { override fun process () = sequence { waitingLine . add ( this @Customer ) if ( clerk . isPassive ) clerk . activate () passivate () } } class Clerk : Component () { val waitingLine : ComponentQueue < Customer > by inject () override fun process () = sequence { while ( true ) { while ( waitingLine . isEmpty ()) passivate () val customer = waitingLine . poll () hold ( 10.0 ) // bearbeitungszeit customer . activate () } } } class CustomerGenerator : Component () { // var numCreated = 0 override fun process () = sequence { // if(numCreated++ >5 ) return@sequence while ( true ) { Customer ( get (), get ()) hold ( uniform ( 5.0 , 15.1 ). sample ()) } } } fun main () { val deps = declareDependencies { add { Clerk () } add { ComponentQueue < Customer > ( \"waiting line\" ) } } val env = createSimulation ( true , dependencies = deps ) { CustomerGenerator () }. run ( 50.0 ) val waitingLine : ComponentQueue < Customer > = env . get () waitingLine . stats . print () if ( canDisplay ()) { waitingLine . queueLengthMonitor . display () waitingLine . lengthOfStayMonitor . display () } } Let's look at some details (marked in yellow for convenience). With: waitingLine . add ( this @Customer ) the customer places itself at the tail of the waiting line. Then, the customer checks whether the clerk is idle, and if so, activates him immediately.: if ( clerk . isPassive ) clerk . activate () Once the clerk is active (again), it gets the first customer out of the waitingline with: val customer = waitingLine . poll () and holds for 30 time units with: hold ( 10.0 ) After that hold the customer is activated and will terminate: customer . activate () In the main section of the program, we create the CustomerGenerator , the Clerk and a ComponentQueue called waitingline. Here the customer generator is implemented as a custom instance of Component for educational puroposes. Using the provided ComponentGenerator API would be more concise. hold ( uniform ( 5.0 , 15.0 ). sample ()) will do the statistical sampling and wait for that time till the next customer is created. Since logging is enabled when creating the simulation with createSimulation the following log trace is being produced time current component action info --------- ------------------------ -------------------------------------------- ---------------------------------- .00 main create .00 main .00 Clerk.1 create .00 Clerk.1 activate scheduled for .00 .00 CustomerGenerator.1 create .00 CustomerGenerator.1 activate scheduled for .00 .00 main run +50.00 scheduled for 50.00 .00 Clerk.1 .00 Clerk.1 passivate .00 CustomerGenerator.1 .00 Customer.1 create .00 Customer.1 activate scheduled for .00 .00 CustomerGenerator.1 hold +11.95 scheduled for 11.95 .00 Customer.1 .00 Customer.1 entering waiting line .00 Clerk.1 activate scheduled for .00 .00 Customer.1 passivate .00 Clerk.1 .00 Customer.1 leaving waiting line .00 Clerk.1 hold +10.00 scheduled for 10.00 10.00 Clerk.1 10.00 Customer.1 activate scheduled for 10.00 10.00 Clerk.1 passivate 10.00 Customer.1 10.00 Customer.1 ended 11.95 CustomerGenerator.1 11.95 Customer.2 create 11.95 Customer.2 activate scheduled for 11.95 11.95 CustomerGenerator.1 hold +7.73 scheduled for 19.68 11.95 Customer.2 11.95 Customer.2 entering waiting line 11.95 Clerk.1 activate scheduled for 11.95 11.95 Customer.2 passivate 11.95 Clerk.1 11.95 Customer.2 leaving waiting line 11.95 Clerk.1 hold +10.00 scheduled for 21.95 19.68 CustomerGenerator.1 19.68 Customer.3 create 19.68 Customer.3 activate scheduled for 19.68 19.68 CustomerGenerator.1 hold +10.32 scheduled for 30.00 19.68 Customer.3 19.68 Customer.3 entering waiting line 19.68 Customer.3 passivate 21.95 Clerk.1 21.95 Customer.2 activate scheduled for 21.95 21.95 Customer.3 leaving waiting line 21.95 Clerk.1 hold +10.00 scheduled for 31.95 21.95 Customer.2 21.95 Customer.2 ended 30.00 CustomerGenerator.1 30.00 Customer.4 create 30.00 Customer.4 activate scheduled for 30.00 30.00 CustomerGenerator.1 hold +10.63 scheduled for 40.63 30.00 Customer.4 30.00 Customer.4 entering waiting line 30.00 Customer.4 passivate 31.95 Clerk.1 31.95 Customer.3 activate scheduled for 31.95 31.95 Customer.4 leaving waiting line 31.95 Clerk.1 hold +10.00 scheduled for 41.95 31.95 Customer.3 31.95 Customer.3 ended 40.63 CustomerGenerator.1 40.63 Customer.5 create 40.63 Customer.5 activate scheduled for 40.63 40.63 CustomerGenerator.1 hold +5.31 scheduled for 45.95 40.63 Customer.5 40.63 Customer.5 entering waiting line 40.63 Customer.5 passivate 41.95 Clerk.1 41.95 Customer.4 activate scheduled for 41.95 41.95 Customer.5 leaving waiting line 41.95 Clerk.1 hold +10.00 scheduled for 51.95 41.95 Customer.4 41.95 Customer.4 ended 45.95 CustomerGenerator.1 45.95 Customer.6 create 45.95 Customer.6 activate scheduled for 45.95 45.95 CustomerGenerator.1 hold +12.68 scheduled for 58.63 45.95 Customer.6 45.95 Customer.6 entering waiting line 45.95 Customer.6 passivate 50.00 main After the simulation is finished, the statistics of the queue are presented with: waitingLine . stats . print () The statistics output looks like { \"queue_length\" : { \"all\" : { \"duration\" : 50 , \"min\" : 0 , \"max\" : 1 , \"mean\" : 0.15 , \"standard_deviation\" : 0.361 }, \"excl_zeros\" : { \"duration\" : 7.500540828621098 , \"min\" : 1 , \"max\" : 1 , \"mean\" : 1 , \"standard_deviation\" : 0 } }, \"name\" : \"waiting line\" , \"length_of_stay\" : { \"all\" : { \"entries\" : 5 , \"ninety_pct_quantile\" : 3.736 , \"median\" : 1.684 , \"mean\" : 1.334 , \"ninetyfive_pct_quantile\" : 3.736 , \"standard_deviation\" : 1.684 }, \"excl_zeros\" : { \"entries\" : 3 , \"ninety_pct_quantile\" : 3.736 , \"median\" : 1.645 , \"mean\" : 2.223 , \"ninetyfive_pct_quantile\" : 3.736 , \"standard_deviation\" : 1.645 } }, \"type\" : \"QueueStatistics\" , \"timestamp\" : 50 } Bank Office with 3 Clerks Now, let's add more clerks: add { ( 1. . 3 ). map { Clerk () } } And, every time a customer enters the waiting line, we need to make sure at least one passive clerk (if any) is activated: for ( c in clerks ) { if ( c . isPassive ) { c . activate () break // activate at max one clerk } } The complete source of a three clerk post office: ////Bank3Clerks.kt package org.kalasim.examples.bank.threeclerks import org.kalasim.* import org.kalasim.plot.kravis.canDisplay import org.kalasim.plot.kravis.display import org.koin.core.component.inject class CustomerGenerator : Component () { override fun process () = sequence { while ( true ) { Customer ( get ()) hold ( uniform ( 5.0 , 15.0 ). sample ()) } } } class Customer ( val waitingLine : ComponentQueue < Customer > ) : Component () { private val clerks : List < Clerk > by inject () override fun process () = sequence { waitingLine . add ( this @Customer ) for ( c in clerks ) { if ( c . isPassive ) { c . activate () break // activate at max one clerk } } passivate () } } class Clerk : Component () { private val waitingLine : ComponentQueue < Customer > by inject () override fun process () = sequence { while ( true ) { if ( waitingLine . isEmpty ()) passivate () val customer = waitingLine . poll () hold ( 30.0 ) // bearbeitungszeit customer . activate () // signal the customer that's all's done } } } fun main () { val env = configureEnvironment { // register components needed for dependency injection add { ComponentQueue < Customer > ( \"waitingline\" ) } add { State ( false , \"worktodo\" ) } add { CustomerGenerator () } add { ( 1. . 3 ). map { Clerk () } } } env . apply { run ( 50000.0 ) val waitingLine : ComponentQueue < Customer > = get () if ( canDisplay ()) { // waitingLine.lengthOfStayMonitor.printHistogram() // waitingLine.queueLengthMonitor.printHistogram() waitingLine . queueLengthMonitor . display () waitingLine . lengthOfStayMonitor . display () } // waitingLine.stats.toJson().toString(2).printThis() waitingLine . printInfo () } } Bank Office with Resources kalasim contains another useful concept for modelling: Resources . Resources have a limited capacity and can be claimed by components and released later. In the model of the bank with the same functionality as the above example, the clerks are defined as a resource with capacity 3. The model code is: ////Bank3ClerksResources.kt package org.kalasim.examples.bank.resources import org.kalasim.* import org.kalasim.plot.kravis.canDisplay import org.kalasim.plot.kravis.display import org.koin.core.component.get class Customer ( private val clerks : Resource ) : Component () { override fun process () = sequence { request ( clerks ) hold ( 30 ) release ( clerks ) // not really required } } fun main () { val env = configureEnvironment { add { Resource ( \"clerks\" , capacity = 3 ) } }. apply { ComponentGenerator ( iat = uniform ( 5.0 , 15.0 )) { Customer ( get ()) } }. run ( 3000 ) env . get < Resource > (). apply { printInfo () if ( canDisplay ()) { claimedTimeline . display () requesters . queueLengthMonitor . display () } printStatistics () } } Let's look at some details.: add { Resource ( \"clerks\" , capacity = 3 ) } This defines a resource with a capacity of 3 . Each customer tries to claim one unit (=clerk) from the resource with: request ( clerks ) B default 1 unit will be requested. If the resource is not available, the customer needs to wait for it to become available (in order of arrival). In contrast with the previous example, the customer now holds itself for 30 time units (clicks). After this time, the customer releases the resource with: release ( clerks ) The effect is that kalasim then tries to honor the next pending request, if any. In this case the release statement is not required, as resources that were claimed are automatically released when a process terminates).` The statistics are maintained in two system queues, called clerk.requesters and clerk.claimers . The output is very similar to the earlier example. The statistics are exactly the same. Bank Office with Balking and Reneging Now, we assume that clients are not going to the queue when there are more than 5 clients waiting (balking). On top of that, if a client is waiting longer than 50, he/she will leave as well (reneging). The model code is: ////Bank3ClerksReneging.kt package org.kalasim.examples.bank.reneging import org.kalasim.* import org.kalasim.misc.printThis import org.koin.core.component.inject //**{todo}** use monitors here and maybe even inject them //to inject use data class Counter(var value: Int) var numBalked : Int = 0 var numReneged : Int = 0 class CustomerGenerator : Component () { override fun process () = sequence { while ( true ) { Customer ( get ()) hold ( uniform ( 5.0 , 15.0 ). sample ()) } } } class Customer ( val waitingLine : ComponentQueue < Customer > ) : Component () { private val clerks : List < Clerk > by inject () override fun process () = sequence { if ( waitingLine . size >= 5 ) { numBalked ++ log ( \"balked\" ) cancel () } waitingLine . add ( this @Customer ) for ( c in clerks ) { if ( c . isPassive ) { c . activate () break // activate only one clerk } } hold ( 50.0 ) // if not serviced within this time, renege if ( waitingLine . contains ( this @Customer )) { // this@Customer.leave(waitingLine) waitingLine . remove ( this @Customer ) numReneged ++ log ( \"reneged\" ) } else { // if customer no longer in waiting line, // serving has started meanwhile passivate () } } } class Clerk : Component () { private val waitingLine : ComponentQueue < Customer > by inject () override fun process () = sequence { while ( true ) { if ( waitingLine . isEmpty ()) passivate () val customer = waitingLine . poll () customer . activate () // get the customer out of it's hold(50) hold ( 30.0 ) // bearbeitungszeit customer . activate () // signal the customer that's all's done } } } fun main () { val env = configureEnvironment ( true ) { // register components needed for dependency injection add { ComponentQueue < Customer > ( \"waitingline\" ) } add { ( 0. . 2 ). map { Clerk () } } } env . apply { // register other components to be present when starting the simulation CustomerGenerator () val waitingLine : ComponentQueue < Customer > = get () waitingLine . lengthOfStayMonitor . enabled = false run ( 1500.0 ) waitingLine . lengthOfStayMonitor . enabled = true run ( 500.0 ) // with console waitingLine . lengthOfStayMonitor . printHistogram () waitingLine . queueLengthMonitor . printHistogram () // with kravis // waitingLine.queueLengthMonitor.display() // waitingLine.lengthOfStayMonitor.display() waitingLine . stats . toJson (). toString ( 2 ). printThis () println ( \"number reneged: $ numReneged \" ) println ( \"number balked: $ numBalked \" ) } } Let's look at some details. cancel () This makes the current component (a customer) a DATA component (and be subject to garbage collection), if the queue length is 5 or more. The reneging is implemented after a hold of 50 . If a clerk can service a customer, it will take the customer out of the waitingline and will activate it at that moment. The customer just has to check whether he/she is still in the waiting line. If so, he/she has not been serviced in time and thus will renege. hold ( 50.0 ) if ( waitingLine . contains ( this @Customer )) { waitingLine . leave ( this @Customer ) numReneged ++ printTrace ( \"reneged\" ) } else { passivate () } All the clerk has to do when starting servicing a client is to get the next customer in line out of the queue (as before) and activate this customer (at time now). The effect is that the hold of the customer will end. hold ( 30.0 ) customer . activate () // signal the customer that's all's done Bank Office with Balking and Reneging (resources) Now we show how balking and reneging can be implemented with resources. The model code is: ////Bank3ClerksRenegingResources.kt package org.kalasim.examples.bank.reneging_resources import org.kalasim.* import org.koin.core.component.get //var numBalked = LevelMonitoredInt(0) var numBalked = 0 var numReneged = 0 class Customer ( val clerks : Resource ) : Component () { override fun process () = sequence { if ( clerks . requesters . size >= 5 ) { numBalked ++ log ( \"balked\" ) cancel () } request ( clerks , failDelay = 50 ) if ( failed ) { numReneged ++ log ( \"reneged\" ) } else { hold ( 30 ) release ( clerks ) } } } fun main () { declareDependencies { add { Resource ( \"clerks\" , capacity = 3 ) } }. createSimulation { // register other components to be present when starting the simulation ComponentGenerator ( iat = uniform ( 5.0 , 15.0 )) { Customer ( get ()) } run ( 50000.0 ) val clerks = get < Resource > () // with console clerks . requesters . queueLengthMonitor . printHistogram () clerks . requesters . lengthOfStayMonitor . printHistogram () // with kravis // clerks.requesters.queueLengthMonitor.display() // clerks.requesters.lengthOfStayMonitor.display() println ( \"number reneged: $ numReneged \" ) println ( \"number balked: $ numBalked \" ) } } As you can see, the balking part is exactly the same as in the example without resources. For the renenging, all we have to do is add a failDelay : request ( clerks , failDelay = 50. asDist ()) If the request is not honored within 50 time units (ticks), the process continues after that request statement. We check whether the request has failed with the built-in Component property: iff ( failed ) numReneged ++ This example shows clearly the advantage of the resource solution over the passivate / activate method, in former example. Bank Office with States Another useful concept for modelling are states . In this case, we define a state called worktodo . The model code is: ////Bank3ClerksState.kt package org.kalasim.examples.bank.state import org.apache.commons.math3.distribution.UniformRealDistribution import org.kalasim.* import org.koin.core.component.inject class CustomerGenerator : Component () { override fun process () = sequence { while ( true ) { Customer ( get (), get ()) hold ( UniformRealDistribution ( env . rg , 5.0 , 15.0 ). sample ()) } } } class Customer ( val workTodo : State < Boolean > , val waitingLine : ComponentQueue < Customer > ) : Component () { override fun process () = sequence { waitingLine . add ( this @Customer ) workTodo . trigger ( true , max = 1 ) passivate () } } class Clerk : Component () { val waitingLine : ComponentQueue < Customer > by inject () val workTodo : State < Boolean > by inject () override fun process () = sequence { while ( true ) { if ( waitingLine . isEmpty ()) wait ( workTodo , true ) val customer = waitingLine . poll () hold ( 32.0 ) // bearbeitungszeit customer . activate () } } } fun main () { val env = declareDependencies { // register components needed for dependency injection add { ComponentQueue < Customer > ( \"waitingline\" ) } add { State ( false , \"worktodo\" ) } }. createSimulation ( true ) { // register other components to be present // when starting the simulation repeat ( 3 ) { Clerk () } CustomerGenerator () }. run ( 500.0 ) env . get < ComponentQueue < Customer >> (). printStats () env . get < State < Boolean >> (). printInfo () // val waitingLine: ComponentQueue<Customer> = env.get() // waitingLine.stats.print() // waitingLine.queueLengthMonitor.display() } Let's look at some details. add { State ( false , \"worktodo\" ) } This defines a state with an initial value false and registers it as a dependency. In the code of the customer, the customer tries to trigger one clerk with: workTodo . trigger ( true , max = 1 ) The effect is that if there are clerks waiting for worktodo, the first clerk's wait is honored and that clerk continues its process after: wait ( workTodo , true ) Note that the clerk is only going to wait for worktodo after completion of a job if there are no customers waiting. Bank Office with Standby The kalasim package contains yet another powerful process mechanism, called standby . When a component is in STANDBY mode, it will become current after each event. Normally, the standby will be used in a while loop where at every event one or more conditions are checked. The model with standby is: ////Bank3ClerksStandby.kt import org.kalasim.* import org.kalasim.plot.kravis.display import org.koin.core.component.get import org.koin.core.component.inject class Customer ( val waitingLine : ComponentQueue < Customer > ) : Component () { override fun process () = sequence { waitingLine . add ( this @Customer ) passivate () } } class Clerk : Component () { val waitingLine : ComponentQueue < Customer > by inject () override fun process () = sequence { while ( true ) { while ( waitingLine . isEmpty ()) standby () val customer = waitingLine . poll () hold ( 32.0 ) // bearbeitungszeit customer . activate () } } } fun main () { val env = declareDependencies { add { ComponentQueue < Customer > ( \"waitingline\" ) } }. createSimulation ( true ) { repeat ( 3 ) { Clerk () } ComponentGenerator ( uniform ( 5 , 15 )) { Customer ( get ()) } } env . run ( 500.0 ) env . get < ComponentQueue < Customer >> (). apply { printInfo () printStats () lengthOfStayMonitor . display () } } In this case, the condition is checked frequently with: while ( waitingLine . isEmpty ()) standby () The rest of the code is very similar to the version with states. Warning It is very important to realize that this mechanism can have significant impact on the performance, as after EACH event, the component becomes current and has to be checked. In general, it is recommended to try and use state s or a more straightforward passivate / activate construction.","title":"Bank Office"},{"location":"examples/bank_office/#simple-bank-office-1-clerk","text":"Lets start with a bank office where customers are arriving in a bank, where there is one clerk. This clerk handles the customers in a first in first out (FIFO) order. We see the following processes: The customer generator that creates the customers, with an inter-arrival time of uniform(5,15) The customers The clerk, which serves the customers in a constant time of 30 (overloaded and non steady state system) We need a queue for the customers to wait for service. The model code is: ////Bank1clerk.kt package org.kalasim.examples.bank.oneclerk import org.kalasim.* import org.kalasim.plot.kravis.canDisplay import org.kalasim.plot.kravis.display import org.koin.core.component.inject class Customer ( val waitingLine : ComponentQueue < Customer > , val clerk : Clerk ) : Component () { override fun process () = sequence { waitingLine . add ( this @Customer ) if ( clerk . isPassive ) clerk . activate () passivate () } } class Clerk : Component () { val waitingLine : ComponentQueue < Customer > by inject () override fun process () = sequence { while ( true ) { while ( waitingLine . isEmpty ()) passivate () val customer = waitingLine . poll () hold ( 10.0 ) // bearbeitungszeit customer . activate () } } } class CustomerGenerator : Component () { // var numCreated = 0 override fun process () = sequence { // if(numCreated++ >5 ) return@sequence while ( true ) { Customer ( get (), get ()) hold ( uniform ( 5.0 , 15.1 ). sample ()) } } } fun main () { val deps = declareDependencies { add { Clerk () } add { ComponentQueue < Customer > ( \"waiting line\" ) } } val env = createSimulation ( true , dependencies = deps ) { CustomerGenerator () }. run ( 50.0 ) val waitingLine : ComponentQueue < Customer > = env . get () waitingLine . stats . print () if ( canDisplay ()) { waitingLine . queueLengthMonitor . display () waitingLine . lengthOfStayMonitor . display () } } Let's look at some details (marked in yellow for convenience). With: waitingLine . add ( this @Customer ) the customer places itself at the tail of the waiting line. Then, the customer checks whether the clerk is idle, and if so, activates him immediately.: if ( clerk . isPassive ) clerk . activate () Once the clerk is active (again), it gets the first customer out of the waitingline with: val customer = waitingLine . poll () and holds for 30 time units with: hold ( 10.0 ) After that hold the customer is activated and will terminate: customer . activate () In the main section of the program, we create the CustomerGenerator , the Clerk and a ComponentQueue called waitingline. Here the customer generator is implemented as a custom instance of Component for educational puroposes. Using the provided ComponentGenerator API would be more concise. hold ( uniform ( 5.0 , 15.0 ). sample ()) will do the statistical sampling and wait for that time till the next customer is created. Since logging is enabled when creating the simulation with createSimulation the following log trace is being produced time current component action info --------- ------------------------ -------------------------------------------- ---------------------------------- .00 main create .00 main .00 Clerk.1 create .00 Clerk.1 activate scheduled for .00 .00 CustomerGenerator.1 create .00 CustomerGenerator.1 activate scheduled for .00 .00 main run +50.00 scheduled for 50.00 .00 Clerk.1 .00 Clerk.1 passivate .00 CustomerGenerator.1 .00 Customer.1 create .00 Customer.1 activate scheduled for .00 .00 CustomerGenerator.1 hold +11.95 scheduled for 11.95 .00 Customer.1 .00 Customer.1 entering waiting line .00 Clerk.1 activate scheduled for .00 .00 Customer.1 passivate .00 Clerk.1 .00 Customer.1 leaving waiting line .00 Clerk.1 hold +10.00 scheduled for 10.00 10.00 Clerk.1 10.00 Customer.1 activate scheduled for 10.00 10.00 Clerk.1 passivate 10.00 Customer.1 10.00 Customer.1 ended 11.95 CustomerGenerator.1 11.95 Customer.2 create 11.95 Customer.2 activate scheduled for 11.95 11.95 CustomerGenerator.1 hold +7.73 scheduled for 19.68 11.95 Customer.2 11.95 Customer.2 entering waiting line 11.95 Clerk.1 activate scheduled for 11.95 11.95 Customer.2 passivate 11.95 Clerk.1 11.95 Customer.2 leaving waiting line 11.95 Clerk.1 hold +10.00 scheduled for 21.95 19.68 CustomerGenerator.1 19.68 Customer.3 create 19.68 Customer.3 activate scheduled for 19.68 19.68 CustomerGenerator.1 hold +10.32 scheduled for 30.00 19.68 Customer.3 19.68 Customer.3 entering waiting line 19.68 Customer.3 passivate 21.95 Clerk.1 21.95 Customer.2 activate scheduled for 21.95 21.95 Customer.3 leaving waiting line 21.95 Clerk.1 hold +10.00 scheduled for 31.95 21.95 Customer.2 21.95 Customer.2 ended 30.00 CustomerGenerator.1 30.00 Customer.4 create 30.00 Customer.4 activate scheduled for 30.00 30.00 CustomerGenerator.1 hold +10.63 scheduled for 40.63 30.00 Customer.4 30.00 Customer.4 entering waiting line 30.00 Customer.4 passivate 31.95 Clerk.1 31.95 Customer.3 activate scheduled for 31.95 31.95 Customer.4 leaving waiting line 31.95 Clerk.1 hold +10.00 scheduled for 41.95 31.95 Customer.3 31.95 Customer.3 ended 40.63 CustomerGenerator.1 40.63 Customer.5 create 40.63 Customer.5 activate scheduled for 40.63 40.63 CustomerGenerator.1 hold +5.31 scheduled for 45.95 40.63 Customer.5 40.63 Customer.5 entering waiting line 40.63 Customer.5 passivate 41.95 Clerk.1 41.95 Customer.4 activate scheduled for 41.95 41.95 Customer.5 leaving waiting line 41.95 Clerk.1 hold +10.00 scheduled for 51.95 41.95 Customer.4 41.95 Customer.4 ended 45.95 CustomerGenerator.1 45.95 Customer.6 create 45.95 Customer.6 activate scheduled for 45.95 45.95 CustomerGenerator.1 hold +12.68 scheduled for 58.63 45.95 Customer.6 45.95 Customer.6 entering waiting line 45.95 Customer.6 passivate 50.00 main After the simulation is finished, the statistics of the queue are presented with: waitingLine . stats . print () The statistics output looks like { \"queue_length\" : { \"all\" : { \"duration\" : 50 , \"min\" : 0 , \"max\" : 1 , \"mean\" : 0.15 , \"standard_deviation\" : 0.361 }, \"excl_zeros\" : { \"duration\" : 7.500540828621098 , \"min\" : 1 , \"max\" : 1 , \"mean\" : 1 , \"standard_deviation\" : 0 } }, \"name\" : \"waiting line\" , \"length_of_stay\" : { \"all\" : { \"entries\" : 5 , \"ninety_pct_quantile\" : 3.736 , \"median\" : 1.684 , \"mean\" : 1.334 , \"ninetyfive_pct_quantile\" : 3.736 , \"standard_deviation\" : 1.684 }, \"excl_zeros\" : { \"entries\" : 3 , \"ninety_pct_quantile\" : 3.736 , \"median\" : 1.645 , \"mean\" : 2.223 , \"ninetyfive_pct_quantile\" : 3.736 , \"standard_deviation\" : 1.645 } }, \"type\" : \"QueueStatistics\" , \"timestamp\" : 50 }","title":"Simple Bank Office (1 clerk)"},{"location":"examples/bank_office/#bank-office-with-3-clerks","text":"Now, let's add more clerks: add { ( 1. . 3 ). map { Clerk () } } And, every time a customer enters the waiting line, we need to make sure at least one passive clerk (if any) is activated: for ( c in clerks ) { if ( c . isPassive ) { c . activate () break // activate at max one clerk } } The complete source of a three clerk post office: ////Bank3Clerks.kt package org.kalasim.examples.bank.threeclerks import org.kalasim.* import org.kalasim.plot.kravis.canDisplay import org.kalasim.plot.kravis.display import org.koin.core.component.inject class CustomerGenerator : Component () { override fun process () = sequence { while ( true ) { Customer ( get ()) hold ( uniform ( 5.0 , 15.0 ). sample ()) } } } class Customer ( val waitingLine : ComponentQueue < Customer > ) : Component () { private val clerks : List < Clerk > by inject () override fun process () = sequence { waitingLine . add ( this @Customer ) for ( c in clerks ) { if ( c . isPassive ) { c . activate () break // activate at max one clerk } } passivate () } } class Clerk : Component () { private val waitingLine : ComponentQueue < Customer > by inject () override fun process () = sequence { while ( true ) { if ( waitingLine . isEmpty ()) passivate () val customer = waitingLine . poll () hold ( 30.0 ) // bearbeitungszeit customer . activate () // signal the customer that's all's done } } } fun main () { val env = configureEnvironment { // register components needed for dependency injection add { ComponentQueue < Customer > ( \"waitingline\" ) } add { State ( false , \"worktodo\" ) } add { CustomerGenerator () } add { ( 1. . 3 ). map { Clerk () } } } env . apply { run ( 50000.0 ) val waitingLine : ComponentQueue < Customer > = get () if ( canDisplay ()) { // waitingLine.lengthOfStayMonitor.printHistogram() // waitingLine.queueLengthMonitor.printHistogram() waitingLine . queueLengthMonitor . display () waitingLine . lengthOfStayMonitor . display () } // waitingLine.stats.toJson().toString(2).printThis() waitingLine . printInfo () } }","title":"Bank Office with 3 Clerks"},{"location":"examples/bank_office/#bank-office-with-resources","text":"kalasim contains another useful concept for modelling: Resources . Resources have a limited capacity and can be claimed by components and released later. In the model of the bank with the same functionality as the above example, the clerks are defined as a resource with capacity 3. The model code is: ////Bank3ClerksResources.kt package org.kalasim.examples.bank.resources import org.kalasim.* import org.kalasim.plot.kravis.canDisplay import org.kalasim.plot.kravis.display import org.koin.core.component.get class Customer ( private val clerks : Resource ) : Component () { override fun process () = sequence { request ( clerks ) hold ( 30 ) release ( clerks ) // not really required } } fun main () { val env = configureEnvironment { add { Resource ( \"clerks\" , capacity = 3 ) } }. apply { ComponentGenerator ( iat = uniform ( 5.0 , 15.0 )) { Customer ( get ()) } }. run ( 3000 ) env . get < Resource > (). apply { printInfo () if ( canDisplay ()) { claimedTimeline . display () requesters . queueLengthMonitor . display () } printStatistics () } } Let's look at some details.: add { Resource ( \"clerks\" , capacity = 3 ) } This defines a resource with a capacity of 3 . Each customer tries to claim one unit (=clerk) from the resource with: request ( clerks ) B default 1 unit will be requested. If the resource is not available, the customer needs to wait for it to become available (in order of arrival). In contrast with the previous example, the customer now holds itself for 30 time units (clicks). After this time, the customer releases the resource with: release ( clerks ) The effect is that kalasim then tries to honor the next pending request, if any. In this case the release statement is not required, as resources that were claimed are automatically released when a process terminates).` The statistics are maintained in two system queues, called clerk.requesters and clerk.claimers . The output is very similar to the earlier example. The statistics are exactly the same.","title":"Bank Office with Resources"},{"location":"examples/bank_office/#bank-office-with-balking-and-reneging","text":"Now, we assume that clients are not going to the queue when there are more than 5 clients waiting (balking). On top of that, if a client is waiting longer than 50, he/she will leave as well (reneging). The model code is: ////Bank3ClerksReneging.kt package org.kalasim.examples.bank.reneging import org.kalasim.* import org.kalasim.misc.printThis import org.koin.core.component.inject //**{todo}** use monitors here and maybe even inject them //to inject use data class Counter(var value: Int) var numBalked : Int = 0 var numReneged : Int = 0 class CustomerGenerator : Component () { override fun process () = sequence { while ( true ) { Customer ( get ()) hold ( uniform ( 5.0 , 15.0 ). sample ()) } } } class Customer ( val waitingLine : ComponentQueue < Customer > ) : Component () { private val clerks : List < Clerk > by inject () override fun process () = sequence { if ( waitingLine . size >= 5 ) { numBalked ++ log ( \"balked\" ) cancel () } waitingLine . add ( this @Customer ) for ( c in clerks ) { if ( c . isPassive ) { c . activate () break // activate only one clerk } } hold ( 50.0 ) // if not serviced within this time, renege if ( waitingLine . contains ( this @Customer )) { // this@Customer.leave(waitingLine) waitingLine . remove ( this @Customer ) numReneged ++ log ( \"reneged\" ) } else { // if customer no longer in waiting line, // serving has started meanwhile passivate () } } } class Clerk : Component () { private val waitingLine : ComponentQueue < Customer > by inject () override fun process () = sequence { while ( true ) { if ( waitingLine . isEmpty ()) passivate () val customer = waitingLine . poll () customer . activate () // get the customer out of it's hold(50) hold ( 30.0 ) // bearbeitungszeit customer . activate () // signal the customer that's all's done } } } fun main () { val env = configureEnvironment ( true ) { // register components needed for dependency injection add { ComponentQueue < Customer > ( \"waitingline\" ) } add { ( 0. . 2 ). map { Clerk () } } } env . apply { // register other components to be present when starting the simulation CustomerGenerator () val waitingLine : ComponentQueue < Customer > = get () waitingLine . lengthOfStayMonitor . enabled = false run ( 1500.0 ) waitingLine . lengthOfStayMonitor . enabled = true run ( 500.0 ) // with console waitingLine . lengthOfStayMonitor . printHistogram () waitingLine . queueLengthMonitor . printHistogram () // with kravis // waitingLine.queueLengthMonitor.display() // waitingLine.lengthOfStayMonitor.display() waitingLine . stats . toJson (). toString ( 2 ). printThis () println ( \"number reneged: $ numReneged \" ) println ( \"number balked: $ numBalked \" ) } } Let's look at some details. cancel () This makes the current component (a customer) a DATA component (and be subject to garbage collection), if the queue length is 5 or more. The reneging is implemented after a hold of 50 . If a clerk can service a customer, it will take the customer out of the waitingline and will activate it at that moment. The customer just has to check whether he/she is still in the waiting line. If so, he/she has not been serviced in time and thus will renege. hold ( 50.0 ) if ( waitingLine . contains ( this @Customer )) { waitingLine . leave ( this @Customer ) numReneged ++ printTrace ( \"reneged\" ) } else { passivate () } All the clerk has to do when starting servicing a client is to get the next customer in line out of the queue (as before) and activate this customer (at time now). The effect is that the hold of the customer will end. hold ( 30.0 ) customer . activate () // signal the customer that's all's done","title":"Bank Office with Balking and Reneging"},{"location":"examples/bank_office/#bank-office-with-balking-and-reneging-resources","text":"Now we show how balking and reneging can be implemented with resources. The model code is: ////Bank3ClerksRenegingResources.kt package org.kalasim.examples.bank.reneging_resources import org.kalasim.* import org.koin.core.component.get //var numBalked = LevelMonitoredInt(0) var numBalked = 0 var numReneged = 0 class Customer ( val clerks : Resource ) : Component () { override fun process () = sequence { if ( clerks . requesters . size >= 5 ) { numBalked ++ log ( \"balked\" ) cancel () } request ( clerks , failDelay = 50 ) if ( failed ) { numReneged ++ log ( \"reneged\" ) } else { hold ( 30 ) release ( clerks ) } } } fun main () { declareDependencies { add { Resource ( \"clerks\" , capacity = 3 ) } }. createSimulation { // register other components to be present when starting the simulation ComponentGenerator ( iat = uniform ( 5.0 , 15.0 )) { Customer ( get ()) } run ( 50000.0 ) val clerks = get < Resource > () // with console clerks . requesters . queueLengthMonitor . printHistogram () clerks . requesters . lengthOfStayMonitor . printHistogram () // with kravis // clerks.requesters.queueLengthMonitor.display() // clerks.requesters.lengthOfStayMonitor.display() println ( \"number reneged: $ numReneged \" ) println ( \"number balked: $ numBalked \" ) } } As you can see, the balking part is exactly the same as in the example without resources. For the renenging, all we have to do is add a failDelay : request ( clerks , failDelay = 50. asDist ()) If the request is not honored within 50 time units (ticks), the process continues after that request statement. We check whether the request has failed with the built-in Component property: iff ( failed ) numReneged ++ This example shows clearly the advantage of the resource solution over the passivate / activate method, in former example.","title":"Bank Office with Balking and Reneging (resources)"},{"location":"examples/bank_office/#bank-office-with-states","text":"Another useful concept for modelling are states . In this case, we define a state called worktodo . The model code is: ////Bank3ClerksState.kt package org.kalasim.examples.bank.state import org.apache.commons.math3.distribution.UniformRealDistribution import org.kalasim.* import org.koin.core.component.inject class CustomerGenerator : Component () { override fun process () = sequence { while ( true ) { Customer ( get (), get ()) hold ( UniformRealDistribution ( env . rg , 5.0 , 15.0 ). sample ()) } } } class Customer ( val workTodo : State < Boolean > , val waitingLine : ComponentQueue < Customer > ) : Component () { override fun process () = sequence { waitingLine . add ( this @Customer ) workTodo . trigger ( true , max = 1 ) passivate () } } class Clerk : Component () { val waitingLine : ComponentQueue < Customer > by inject () val workTodo : State < Boolean > by inject () override fun process () = sequence { while ( true ) { if ( waitingLine . isEmpty ()) wait ( workTodo , true ) val customer = waitingLine . poll () hold ( 32.0 ) // bearbeitungszeit customer . activate () } } } fun main () { val env = declareDependencies { // register components needed for dependency injection add { ComponentQueue < Customer > ( \"waitingline\" ) } add { State ( false , \"worktodo\" ) } }. createSimulation ( true ) { // register other components to be present // when starting the simulation repeat ( 3 ) { Clerk () } CustomerGenerator () }. run ( 500.0 ) env . get < ComponentQueue < Customer >> (). printStats () env . get < State < Boolean >> (). printInfo () // val waitingLine: ComponentQueue<Customer> = env.get() // waitingLine.stats.print() // waitingLine.queueLengthMonitor.display() } Let's look at some details. add { State ( false , \"worktodo\" ) } This defines a state with an initial value false and registers it as a dependency. In the code of the customer, the customer tries to trigger one clerk with: workTodo . trigger ( true , max = 1 ) The effect is that if there are clerks waiting for worktodo, the first clerk's wait is honored and that clerk continues its process after: wait ( workTodo , true ) Note that the clerk is only going to wait for worktodo after completion of a job if there are no customers waiting.","title":"Bank Office with States"},{"location":"examples/bank_office/#bank-office-with-standby","text":"The kalasim package contains yet another powerful process mechanism, called standby . When a component is in STANDBY mode, it will become current after each event. Normally, the standby will be used in a while loop where at every event one or more conditions are checked. The model with standby is: ////Bank3ClerksStandby.kt import org.kalasim.* import org.kalasim.plot.kravis.display import org.koin.core.component.get import org.koin.core.component.inject class Customer ( val waitingLine : ComponentQueue < Customer > ) : Component () { override fun process () = sequence { waitingLine . add ( this @Customer ) passivate () } } class Clerk : Component () { val waitingLine : ComponentQueue < Customer > by inject () override fun process () = sequence { while ( true ) { while ( waitingLine . isEmpty ()) standby () val customer = waitingLine . poll () hold ( 32.0 ) // bearbeitungszeit customer . activate () } } } fun main () { val env = declareDependencies { add { ComponentQueue < Customer > ( \"waitingline\" ) } }. createSimulation ( true ) { repeat ( 3 ) { Clerk () } ComponentGenerator ( uniform ( 5 , 15 )) { Customer ( get ()) } } env . run ( 500.0 ) env . get < ComponentQueue < Customer >> (). apply { printInfo () printStats () lengthOfStayMonitor . display () } } In this case, the condition is checked frequently with: while ( waitingLine . isEmpty ()) standby () The rest of the code is very similar to the version with states. Warning It is very important to realize that this mechanism can have significant impact on the performance, as after EACH event, the component becomes current and has to be checked. In general, it is recommended to try and use state s or a more straightforward passivate / activate construction.","title":"Bank Office with Standby"},{"location":"examples/bridge_game/","text":"The Bridge Game The glass bridge is a game in the Netflix series The Squid Game . The series is Netflix's most-watched series to date, becoming the top-viewed program in 94 countries and attracting more than 142 million member households during its first four weeks from launch. (Source Wikipedia ) Spoiler Alert Don't read the article if you intend to watch the series! Squid Game - \u00a9 Netflix 2021 In one scene in Episode 7, 16 players have to cross a bridge made of two rows of glass tiles. The bridge is 18 steps long. They have to jump to one tile per row, but just one tile will last whereas the other one is made of tempered glass, which breaks under impact. The players start in an ordered fashion, whereby players with higher numbers will avoid broken tiles. To penalize players with higher numbers, there is a time-limit after which players who have not passed the bridge have lost as well (and pay with their lives). Disclaimer The author considers the game purely from a scientific/fictional perspective. The game as well as the concept of the series are immoral, wrong, and detestable. Squid Game - \u00a9 Netflix 2021 Inspired by another simulation this example illustrates how to run simulations in different configurations many times to work out process parameters. Here, the key parameter of interest is the number of surviving players . As players in the show can pick their start number, the episode - as well as the internet community - circles around the question regarding an optimal start number to optimize the chance of survival . Model To answer this question, we will model and analyze the process with kalasim . At its heart - which is its process definition - it is a very simplistic model that centers around simulating the participant's stepping on the tiles one after another while considering the learning experience of earlier participants with lower start numbers. class SquidGame ( val numSteps : Int = 18 , val numPlayers : Int = 16 , val maxDuration : Int = 12 * 60 ) : Environment ( randomSeed = Random . nextInt ()) { // randomization val stepTime = LogNormalDistribution ( rg , 3.0 , 0.88 ) // val stepTime = uniform(10,30) val decision = enumerated ( true , false ) // state var stepsLeft = numSteps var survivors = mutableListOf < Int > () val numTrials : Int get () = numSteps - survivors . size val numSurvivors : Int get () = survivors . size fun playerSurvived ( playerNo : Int ) = survivors . contains ( playerNo ) init { object : Component () { override fun process () = sequence { queue@ for ( player in 1. . numPlayers ){ hold ( min ( stepTime (), 100.0 )) // cap time at 100sec while ( stepsLeft -- > 0 ){ if ( decision ()) continue @queue hold ( min ( stepTime (), 100.0 )) // cap time at 100sec } if ( now > maxDuration ) break survivors . add ( player ) } } } } } Move times are modeled using a log-normal distribution with the parameters from here . Similar to the previous work, we cap the time it takes a player to make a move (or just part of it) at 100 seconds. To get started, we can simply run the simulation with val sim = SquidGame () sim . run () println ( \" ${ sim . numSurvivors } survived\" ) 5 survived sim . playerSurvived ( 13 ) true ( 1. . 18 ). map { sim . playerSurvived ( it )} [false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, false, false] The model seems fine at first glance. In particular, the impact of timing becomes visible, as the last player did not survive the game Some players survived the game. But clearly, running it once does not tell much about the average number of survivors. So we run it many times and visualize the distribution. val manyGames = org . kalasim . misc . repeat ( 10000 ) { SquidGame (). apply { run () } } val avgSurvivors = manyGames . map { it . numSurvivors }. average () println ( \"The average number of survivors is $ avgSurvivors \" ) The average number of survivors is 5.436 Now since we have sampled the process, we can also easily visualize the survival count distribution manyGames . plot ( x = { numSurvivors }). geomBar (). labs ( title = \"Outcomes of 10,000 trials\" , x = \"Number of survivors\" , y = \"Count\" ) As we learn from the plot, we have obtained predominantly uni-modal distribution with an average of around 6 and minor zero-inflation. So on average 6 players will survive the game. Maximize Survival To better understand the process, we want to visualize the probability of survival based on the player order number. val survivalProbByNo = ( 1. . manyGames . first (). numPlayers ). map { playerNo -> playerNo to manyGames . count { it . playerSurvived ( playerNo ) }. toDouble () / manyGames . size } survivalProbByNo . plot ( x = { it . first }, y = { it . second }). geomCol (). labs ( title = \"Probability of survival based on player order number\" , x = \"Player Order Number\" , y = \"Probability\" ) So indeed there seems a strategy to maximize your odds of survival in the game. Simply pick No13 , and you may live more likely compared to any other starting number. Game Continuation Now, we calculate the probability of having less than two survivors. That's in particular relevant in the series, as the bridge game is not meant to be the last game, and at least 2 players are required to continue the games. val probLT2Players = manyGames . count { it . numSurvivors < 2 }. toDouble () / manyGames . size println ( \"The probability for less than 2 players is $ probLT2Players \" ) The probability for less than 2 players is 0.0771 One may wonder why the makers of the series have placed 18 steps and not more or less? What do the numbers say? What are the odds for game continuation (# survivors >2) when the number of steps is different? To answer these questions, let's re-run the model while varying the steps. To keep things simple, we run 10,000 iterations of the game over an increasing number of steps from 10 to 30: val stepSims = ( 10. . 30 ). flatMap { numSteps -> org . kalasim . misc . repeat ( 10000 ) { SquidGame ( numSteps = numSteps ). apply { run () } } } val stepSimSummary = stepSims . groupBy { it . numSteps }. map { ( steps , games ) -> steps to games . count { it . numSurvivors < 2 }. toDouble () / games . size } stepSimSummary . plot ( x = { it . first }, y = { it . second }). geomCol (). labs ( title = \"Probability of having less than two remaining players\" , x = \"Number of bridge steps\" , y = \"Probability\" ) With more than 16 steps, the odds of having more than 2 players decay quickly. Conclusion In this example we have explored a simple generative model. By means of simulation we have worked out an optimal strategy to survive the bridge game. But be reminded, if you ever find an invite to a squid-like game on your doorstep in times of despair , trash it, smoke it or eat it. There are better - and more fun - ways to make money, such as optimizing real-world processes with simulation and business intelligence. For complete sources, also see the jupyter notebook . Feel welcome to get in touch for support, suggestions, and questions.","title":"Bridge Game"},{"location":"examples/bridge_game/#the-bridge-game","text":"The glass bridge is a game in the Netflix series The Squid Game . The series is Netflix's most-watched series to date, becoming the top-viewed program in 94 countries and attracting more than 142 million member households during its first four weeks from launch. (Source Wikipedia ) Spoiler Alert Don't read the article if you intend to watch the series! Squid Game - \u00a9 Netflix 2021 In one scene in Episode 7, 16 players have to cross a bridge made of two rows of glass tiles. The bridge is 18 steps long. They have to jump to one tile per row, but just one tile will last whereas the other one is made of tempered glass, which breaks under impact. The players start in an ordered fashion, whereby players with higher numbers will avoid broken tiles. To penalize players with higher numbers, there is a time-limit after which players who have not passed the bridge have lost as well (and pay with their lives). Disclaimer The author considers the game purely from a scientific/fictional perspective. The game as well as the concept of the series are immoral, wrong, and detestable. Squid Game - \u00a9 Netflix 2021 Inspired by another simulation this example illustrates how to run simulations in different configurations many times to work out process parameters. Here, the key parameter of interest is the number of surviving players . As players in the show can pick their start number, the episode - as well as the internet community - circles around the question regarding an optimal start number to optimize the chance of survival .","title":"The Bridge Game"},{"location":"examples/bridge_game/#model","text":"To answer this question, we will model and analyze the process with kalasim . At its heart - which is its process definition - it is a very simplistic model that centers around simulating the participant's stepping on the tiles one after another while considering the learning experience of earlier participants with lower start numbers. class SquidGame ( val numSteps : Int = 18 , val numPlayers : Int = 16 , val maxDuration : Int = 12 * 60 ) : Environment ( randomSeed = Random . nextInt ()) { // randomization val stepTime = LogNormalDistribution ( rg , 3.0 , 0.88 ) // val stepTime = uniform(10,30) val decision = enumerated ( true , false ) // state var stepsLeft = numSteps var survivors = mutableListOf < Int > () val numTrials : Int get () = numSteps - survivors . size val numSurvivors : Int get () = survivors . size fun playerSurvived ( playerNo : Int ) = survivors . contains ( playerNo ) init { object : Component () { override fun process () = sequence { queue@ for ( player in 1. . numPlayers ){ hold ( min ( stepTime (), 100.0 )) // cap time at 100sec while ( stepsLeft -- > 0 ){ if ( decision ()) continue @queue hold ( min ( stepTime (), 100.0 )) // cap time at 100sec } if ( now > maxDuration ) break survivors . add ( player ) } } } } } Move times are modeled using a log-normal distribution with the parameters from here . Similar to the previous work, we cap the time it takes a player to make a move (or just part of it) at 100 seconds. To get started, we can simply run the simulation with val sim = SquidGame () sim . run () println ( \" ${ sim . numSurvivors } survived\" ) 5 survived sim . playerSurvived ( 13 ) true ( 1. . 18 ). map { sim . playerSurvived ( it )} [false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, false, false] The model seems fine at first glance. In particular, the impact of timing becomes visible, as the last player did not survive the game Some players survived the game. But clearly, running it once does not tell much about the average number of survivors. So we run it many times and visualize the distribution. val manyGames = org . kalasim . misc . repeat ( 10000 ) { SquidGame (). apply { run () } } val avgSurvivors = manyGames . map { it . numSurvivors }. average () println ( \"The average number of survivors is $ avgSurvivors \" ) The average number of survivors is 5.436 Now since we have sampled the process, we can also easily visualize the survival count distribution manyGames . plot ( x = { numSurvivors }). geomBar (). labs ( title = \"Outcomes of 10,000 trials\" , x = \"Number of survivors\" , y = \"Count\" ) As we learn from the plot, we have obtained predominantly uni-modal distribution with an average of around 6 and minor zero-inflation. So on average 6 players will survive the game.","title":"Model"},{"location":"examples/bridge_game/#maximize-survival","text":"To better understand the process, we want to visualize the probability of survival based on the player order number. val survivalProbByNo = ( 1. . manyGames . first (). numPlayers ). map { playerNo -> playerNo to manyGames . count { it . playerSurvived ( playerNo ) }. toDouble () / manyGames . size } survivalProbByNo . plot ( x = { it . first }, y = { it . second }). geomCol (). labs ( title = \"Probability of survival based on player order number\" , x = \"Player Order Number\" , y = \"Probability\" ) So indeed there seems a strategy to maximize your odds of survival in the game. Simply pick No13 , and you may live more likely compared to any other starting number.","title":"Maximize Survival"},{"location":"examples/bridge_game/#game-continuation","text":"Now, we calculate the probability of having less than two survivors. That's in particular relevant in the series, as the bridge game is not meant to be the last game, and at least 2 players are required to continue the games. val probLT2Players = manyGames . count { it . numSurvivors < 2 }. toDouble () / manyGames . size println ( \"The probability for less than 2 players is $ probLT2Players \" ) The probability for less than 2 players is 0.0771 One may wonder why the makers of the series have placed 18 steps and not more or less? What do the numbers say? What are the odds for game continuation (# survivors >2) when the number of steps is different? To answer these questions, let's re-run the model while varying the steps. To keep things simple, we run 10,000 iterations of the game over an increasing number of steps from 10 to 30: val stepSims = ( 10. . 30 ). flatMap { numSteps -> org . kalasim . misc . repeat ( 10000 ) { SquidGame ( numSteps = numSteps ). apply { run () } } } val stepSimSummary = stepSims . groupBy { it . numSteps }. map { ( steps , games ) -> steps to games . count { it . numSurvivors < 2 }. toDouble () / games . size } stepSimSummary . plot ( x = { it . first }, y = { it . second }). geomCol (). labs ( title = \"Probability of having less than two remaining players\" , x = \"Number of bridge steps\" , y = \"Probability\" ) With more than 16 steps, the odds of having more than 2 players decay quickly.","title":"Game Continuation"},{"location":"examples/bridge_game/#conclusion","text":"In this example we have explored a simple generative model. By means of simulation we have worked out an optimal strategy to survive the bridge game. But be reminded, if you ever find an invite to a squid-like game on your doorstep in times of despair , trash it, smoke it or eat it. There are better - and more fun - ways to make money, such as optimizing real-world processes with simulation and business intelligence. For complete sources, also see the jupyter notebook . Feel welcome to get in touch for support, suggestions, and questions.","title":"Conclusion"},{"location":"examples/car/","text":"A single car, a driver, and red traffic light in the middle of the night. Red Light , Matthias Ripp (CC BY 2.0) Let\u2019s start with a very simple model. The example demonstrates the main mode of operation, the core API and the component process model implemented in kalasim . We want to build a simulation where a single car is driving around for a some time before stopping in front of a red traffic light. ////Cars.kts import org.kalasim.* class Driver : Resource () class TrafficLight : State < String > ( \"red\" ) class Car : Component () { val trafficLight = get < TrafficLight > () val driver = get < Driver > () override fun process () = sequence { request ( driver ) { hold ( 1.0 , description = \"driving\" ) wait ( trafficLight , \"green\" ) } } } createSimulation ( enableConsoleLogger = true ) { dependency { TrafficLight () } dependency { Driver () } Car () }. run ( 5.0 ) For each (active) component we (can) define a type such as: class Car : Component () The class inherits from org.kalasim.Component . Our car depends on a state TrafficLight and resource Driver for operation. To implement that, we first declare these dependencies with dependency{} in the main body of the simulation, and secondly inject them into our car with get<T> . Note, we could also directly inject states and resources with dependency {State(\"red\")} without sub-classing. Although it is possible to define other processes within a class, the standard way is to define a generator function called process in the class. A generator is a function that returns Sequence<Component> . Within these process definitions we use suspend able interaction function calls as a signal to give control to the centralized event loop . In this example, hold ( 1.0 ) suspends execution control and comes back after 1 time unit (referred to as tick ). Apart from hold , kalasim supports a rich vocabulary of interaction methods including passivate , request , wait and component . The main body of every kalasim model usually starts with: createSimulation(enableConsoleLogger = true){ ... } Here, we enable event logging of state changes to see the status of simulation on the console. After declaring our dependencies, we instantiate a single car with Car() . It automatically is assigned the name Car.0 . As there is a generator function called process in Car , this process description will be activated (by default at time now , which is 0 by default at the beginning of a simulation). It is possible to start a process later, but this is by far the most common way to start a process. With run ( 5.0 ) we start the simulation and get back control after 5 ticks. A component called main is defined under the hood to get access to the main process. When we run this program, we get the following output (displayed as table for convenience): time current receiver action info ------ -------- --------- ---------------------------------- ------------------- .00 main Created .00 main .00 Driver.1 Created capacity=1 .00 Car.1 Created .00 activate scheduled for .00 .00 main run +5.00 scheduled for 5.00 .00 Car.1 Car.1 .00 Requesting 1.0 from Driver.1 .00 Claimed 1.0 from 'Car.1' .00 Request honor Driver.1 scheduled for .00 .00 .00 hold +1.00 scheduled for 1.00 1.00 1.00 entering waiters of TrafficLight.1 1.00 wait scheduled for <inf> 5.00 main main Process finished with exit code 0 There are plenty of other more advanced (that is more fun !) examples listed in examples chapter.","title":"Car"},{"location":"examples/car_wash/","text":"In this example, we'll learn how to wait for resources. The example is adopted from the SimPy example . We simulate a carwash with a limited number of machines and a number of cars that arrive at the carwash to get cleaned. The carwash uses a resource to model the limited number of washing machines. It also defines a process for washing a car. When a car arrives at the carwash, it requests a machine. Once it got one, it starts the carwash\u2019s wash processes and waits for it to finish. It finally releases the machine and leaves. The cars are generated by a setup process. After creating an initial amount of cars it creates new car processes after a random time interval as long as the simulation continues. ////CarWash.kt import org.kalasim.* /** * A carwash has a limited number of washing machines and defines * a washing processes that takes some (random) time. * * Car processes arrive at the carwash at a random time. If one washing * machine is available, they start the washing process and wait for it * to finish. If not, they wait until they an use one. */ fun main () { val RANDOM_SEED = 42 val NUM_MACHINES = 2 // Number of machines in the carwash val WASHTIME = 5 // Minutes it takes to clean a car val T_INTER = 7.0 // Create a car every ~7 minutes val SIM_TIME = 20 // Simulation time in minutes class Car : Component () { override fun process () = sequence { val carWash = get < Resource > () request ( carWash ) hold ( WASHTIME ) release ( carWash ) } } val env = declareDependencies { add { Resource ( \"carwash\" , NUM_MACHINES ) } }. createSimulation ( true , randomSeed = RANDOM_SEED ) { //Create 4 initial cars repeat ( 3 ) { Car () } // Create more cars while the simulation is running ComponentGenerator ( iat = uniform ( T_INTER - 2 , T_INTER + 2 )) { Car () } } println ( \"Carwash\\n======\\n\" ) println ( \"Check out http://youtu.be/fXXmeP9TvBg while simulating ... ;-)\" ) // Start the simulation env . run ( until = SIM_TIME . asTickTime ()) }","title":"Car Wash"},{"location":"examples/dining_philosophers/","text":"The Dining Philosophers problem is a classical example in computer science to illustrate synchronisation issues in concurrent processes. It was originally formulated in 1965 by E. W. Dijkstra as a student exam exercise, and was later reworked in its current form by Tony Hoare : Some philosophers sit at a round table with bowls of spaghetti with tomato sauce and tasty cheese. Forks are placed between each pair of adjacent philosophers. Each philosopher must alternately think and eat. However, a philosopher can only eat spaghetti when they have both left and right forks. Each fork can be held by only one philosopher and so a philosopher can use the fork only if it is not being used by another philosopher. After an individual philosopher finishes eating, they need to put down both forks so that the forks become available to others. A philosopher can take the fork on their right or the one on their left as they become available, but cannot start eating before getting both forks. The problem is how to design a discipline of behavior (a concurrent algorithm) such that no philosopher will starve; i.e., each can forever continue to alternate between eating and thinking, assuming no philosopher can know when others may want to eat or think. Simulation Let us define each philosopher as a process executing a thinking + eating loop, and acting concurrently on shared resources (the forks). Each process will follow a similar trajectory in which they Spend some random time thinking until they become hungry. Take one fork, when available, following a given policy. After some lag, take the other fork, when available. Spend some random time eating. Put both forks down and go back to 1. The following function sets up a simulation of $N$ dining philosophers as established above: ////DiningPhilosophers.kt package org.kalasim.examples import krangl.* import kravis.geomSegment import kravis.plot import org.kalasim.* import org.kalasim.misc.repeat fun main () { class Fork : Resource () class Philosopher ( name : String , val leftFork : Fork , val rightFork : Fork ) : Component ( name ) { val thinking = exponential ( 1 ) val eating = exponential ( 1 ) override fun process () = sequence { while ( true ) { hold ( thinking ()) request ( leftFork ) { hold ( 0.1 ) // wait before taking the second fork request ( rightFork ) { hold ( eating ()) log ( \" $ name is eating\" ) } } } } } val sim = createSimulation ( true ) { val ec = collect < Event > () // create forks and resources val names = listOf ( \"Socrates\" , \"Pythagoras\" , \"Plato\" , \"Aristotle\" ) val forks = repeat ( names . size ) { Fork () } //.repeat().take(names.size + 1).toList() names . forEachIndexed { idx , name -> Philosopher ( name , forks [ idx ] , forks [ ( idx + 1 ). rem ( forks . size ) ] ) } run ( 50 ) } // Analysis (gather monitoring data (as in simmer:get_mon_arrivals) data class RequestRecord ( val requester : String , val timestamp : TickTime , val resource : String , val quantity : Double ) val tc = sim . get < EventLog > () val requests = tc . filterIsInstance < ResourceEvent > (). map { val amountDirected = ( if ( it . type == ResourceEventType . RELEASED ) - 1 else 1 ) * it . amount RequestRecord ( it . requester . name , it . time , it . resource . name , amountDirected ) } // transform data into shape suiteable for interval plotting val requestsDf = requests . asDataFrame () . groupBy ( \"requester\" ) . sortedBy ( \"requester\" , \"timestamp\" ) . addColumn ( \"end_time\" ) { it [ \"timestamp\" ] . lag () } . addColumn ( \"state\" ) { rowNumber . map { if ( it . rem ( 2 ) == 0 ) \"hungry\" else \"eating\" } } . filter { it [ \"quantity\" ] gt 0 } . ungroup () // visualize with kravis requestsDf . plot ( x = \"timestamp\" , xend = \"end_time\" , y = \"requester\" , yend = \"requester\" , color = \"state\" ) . geomSegment ( size = 15.0 ) } To enable a strictly typed simulation, we declare the resource Fork and component Philosopher . The latter is associated to a process where the philosopher first thinks for some exponentially distributed time, takes a fork, meditates for a brief second, and finally takes the second fork once it becomes available. Both interactions modelled as request s where we use a self-releasing request context. Once the philosopher has eaten, the whole process starts over again. A variable number of philosophers (here N=4) is instantiated and are equipped with forks on their left and right. Our implementation follows the solution originally proposed by Dijkstra, which establishes the convention that all resources must be requested in order. This means that, in our simulation, Aristotle should pick fork 1 first instead. Without that convention, the simulation would stop soon at a point in which every philosopher holds one fork and waits for the other to be available. Finally, we can transform the resulting monitoring data with krangl and visualize it with kravis . See here for a jupyter notebook implementation of this example. This example was adopted from the simmer manual .","title":"Dining Philosophers"},{"location":"examples/dining_philosophers/#simulation","text":"Let us define each philosopher as a process executing a thinking + eating loop, and acting concurrently on shared resources (the forks). Each process will follow a similar trajectory in which they Spend some random time thinking until they become hungry. Take one fork, when available, following a given policy. After some lag, take the other fork, when available. Spend some random time eating. Put both forks down and go back to 1. The following function sets up a simulation of $N$ dining philosophers as established above: ////DiningPhilosophers.kt package org.kalasim.examples import krangl.* import kravis.geomSegment import kravis.plot import org.kalasim.* import org.kalasim.misc.repeat fun main () { class Fork : Resource () class Philosopher ( name : String , val leftFork : Fork , val rightFork : Fork ) : Component ( name ) { val thinking = exponential ( 1 ) val eating = exponential ( 1 ) override fun process () = sequence { while ( true ) { hold ( thinking ()) request ( leftFork ) { hold ( 0.1 ) // wait before taking the second fork request ( rightFork ) { hold ( eating ()) log ( \" $ name is eating\" ) } } } } } val sim = createSimulation ( true ) { val ec = collect < Event > () // create forks and resources val names = listOf ( \"Socrates\" , \"Pythagoras\" , \"Plato\" , \"Aristotle\" ) val forks = repeat ( names . size ) { Fork () } //.repeat().take(names.size + 1).toList() names . forEachIndexed { idx , name -> Philosopher ( name , forks [ idx ] , forks [ ( idx + 1 ). rem ( forks . size ) ] ) } run ( 50 ) } // Analysis (gather monitoring data (as in simmer:get_mon_arrivals) data class RequestRecord ( val requester : String , val timestamp : TickTime , val resource : String , val quantity : Double ) val tc = sim . get < EventLog > () val requests = tc . filterIsInstance < ResourceEvent > (). map { val amountDirected = ( if ( it . type == ResourceEventType . RELEASED ) - 1 else 1 ) * it . amount RequestRecord ( it . requester . name , it . time , it . resource . name , amountDirected ) } // transform data into shape suiteable for interval plotting val requestsDf = requests . asDataFrame () . groupBy ( \"requester\" ) . sortedBy ( \"requester\" , \"timestamp\" ) . addColumn ( \"end_time\" ) { it [ \"timestamp\" ] . lag () } . addColumn ( \"state\" ) { rowNumber . map { if ( it . rem ( 2 ) == 0 ) \"hungry\" else \"eating\" } } . filter { it [ \"quantity\" ] gt 0 } . ungroup () // visualize with kravis requestsDf . plot ( x = \"timestamp\" , xend = \"end_time\" , y = \"requester\" , yend = \"requester\" , color = \"state\" ) . geomSegment ( size = 15.0 ) } To enable a strictly typed simulation, we declare the resource Fork and component Philosopher . The latter is associated to a process where the philosopher first thinks for some exponentially distributed time, takes a fork, meditates for a brief second, and finally takes the second fork once it becomes available. Both interactions modelled as request s where we use a self-releasing request context. Once the philosopher has eaten, the whole process starts over again. A variable number of philosophers (here N=4) is instantiated and are equipped with forks on their left and right. Our implementation follows the solution originally proposed by Dijkstra, which establishes the convention that all resources must be requested in order. This means that, in our simulation, Aristotle should pick fork 1 first instead. Without that convention, the simulation would stop soon at a point in which every philosopher holds one fork and waits for the other to be available. Finally, we can transform the resulting monitoring data with krangl and visualize it with kravis . See here for a jupyter notebook implementation of this example. This example was adopted from the simmer manual .","title":"Simulation"},{"location":"examples/emergency_room/","text":"Emergency Room Everyone is enjoying the summer, Covid19 restrictions have been lifted, we all get back to regular exercise and outdoor activities. But once in a while, the inevitable happens: An ill-considered step, a brief second of inattention, and injuries all of all types will happen, that require immediate treatment. Luckily our city hosts a modern hospital with an efficient emergency room where the wounded are being taken care of. To save more lives, the mayor has asked us to review and potentially improve process efficiency in the ER. To do so, we need to realize the following steps Understand the current process and model is as simulation Formulate key objectives to be optimized Assess process statistics and metrics, to unravel potential improvements to help more patients. Explore more optimized decision policies to increase So let's dive right into it without further ado. Process Model Patients are classified two-fold 1. By Severity . The ER is using the well known Emergency Severity Index to triage patients based on the acuity of patients' health care problems, and the number of resources their care is anticipated to require. 2. Type of injury which are defined here Resources Surgery rooms that must be equipped by considering the type (i.e., the family) of surgery to be performed. It will take time to prepare a room for a certain type of injury. These setup times are listed in an excel sheet. Doctors that are qualified for a subset of all possible injuries Process dynamics PD-A Depending on the severity, patients might die if not being treated. Also, if not being treated their severity will increase rather quickly PD-B The more busy the waiting room is, the less efficient surgeries tend to be. This is because of stress (over-allocation of supporting personal and material). It is phenomenon that is often observed complex queuing processes such as manufacturing or customer services. PD-C Depending on the severity, patients will die during surgery PD-D The surgery time correlates with the severity of the injury PD-E During nights fewer new patients arrive compared to the day Clearly, more resources are required in the ER and many supported processes are required to run it. However, we leave these out here, as they are not considered to have a major impact on the overall process efficiency. Choosing a correct level of abstraction with a focus on key actors and resources, is the first key to success when optimizing a complex process. Implementation The tick-unit of the simulation is hours. Key Objectives & Observations The head nurse, who is governing the process based on her long-term experience, is scheduling patients based on the following principle Most urgent injuries first Clearly if possible it would be great to also * Minimize waiting times * Reduce number of surgery room setups Analysis Because of the great variety rooms, we observe a lot of setup steps to prepare surgery rooms. Often even if patients with the same type of injury all already waiting. Process Optimization The idea for model above was orginally formulated by Kramer et al. in 2019 : Other relevant applications arise in the context of health-care, where, for example, patients have to be assigned to surgery rooms that must be equipped by considering the type (i.e., the family) of surgery to be performed. In such cases, the weight usually models a level of urgency for the patient. */ Conclusion & Summary In this article we have worked out a complex process with partially non-intuitive process dynamics can be modelled with kalasim and optimized using insights from operations research. Disclaimer: The author is not a medical doctor, so please excuse possible inprecsion in wording and lack of ER process understanding. Feel welcome to suggest corrections or improvements","title":"Emergyency Room"},{"location":"examples/emergency_room/#emergency-room","text":"Everyone is enjoying the summer, Covid19 restrictions have been lifted, we all get back to regular exercise and outdoor activities. But once in a while, the inevitable happens: An ill-considered step, a brief second of inattention, and injuries all of all types will happen, that require immediate treatment. Luckily our city hosts a modern hospital with an efficient emergency room where the wounded are being taken care of. To save more lives, the mayor has asked us to review and potentially improve process efficiency in the ER. To do so, we need to realize the following steps Understand the current process and model is as simulation Formulate key objectives to be optimized Assess process statistics and metrics, to unravel potential improvements to help more patients. Explore more optimized decision policies to increase So let's dive right into it without further ado.","title":"Emergency Room"},{"location":"examples/emergency_room/#process-model","text":"Patients are classified two-fold 1. By Severity . The ER is using the well known Emergency Severity Index to triage patients based on the acuity of patients' health care problems, and the number of resources their care is anticipated to require. 2. Type of injury which are defined here Resources Surgery rooms that must be equipped by considering the type (i.e., the family) of surgery to be performed. It will take time to prepare a room for a certain type of injury. These setup times are listed in an excel sheet. Doctors that are qualified for a subset of all possible injuries Process dynamics PD-A Depending on the severity, patients might die if not being treated. Also, if not being treated their severity will increase rather quickly PD-B The more busy the waiting room is, the less efficient surgeries tend to be. This is because of stress (over-allocation of supporting personal and material). It is phenomenon that is often observed complex queuing processes such as manufacturing or customer services. PD-C Depending on the severity, patients will die during surgery PD-D The surgery time correlates with the severity of the injury PD-E During nights fewer new patients arrive compared to the day Clearly, more resources are required in the ER and many supported processes are required to run it. However, we leave these out here, as they are not considered to have a major impact on the overall process efficiency. Choosing a correct level of abstraction with a focus on key actors and resources, is the first key to success when optimizing a complex process.","title":"Process Model"},{"location":"examples/emergency_room/#implementation","text":"The tick-unit of the simulation is hours.","title":"Implementation"},{"location":"examples/emergency_room/#key-objectives-observations","text":"The head nurse, who is governing the process based on her long-term experience, is scheduling patients based on the following principle Most urgent injuries first Clearly if possible it would be great to also * Minimize waiting times * Reduce number of surgery room setups","title":"Key Objectives &amp; Observations"},{"location":"examples/emergency_room/#analysis","text":"Because of the great variety rooms, we observe a lot of setup steps to prepare surgery rooms. Often even if patients with the same type of injury all already waiting.","title":"Analysis"},{"location":"examples/emergency_room/#process-optimization","text":"The idea for model above was orginally formulated by Kramer et al. in 2019 : Other relevant applications arise in the context of health-care, where, for example, patients have to be assigned to surgery rooms that must be equipped by considering the type (i.e., the family) of surgery to be performed. In such cases, the weight usually models a level of urgency for the patient. */","title":"Process Optimization"},{"location":"examples/emergency_room/#conclusion-summary","text":"In this article we have worked out a complex process with partially non-intuitive process dynamics can be modelled with kalasim and optimized using insights from operations research. Disclaimer: The author is not a medical doctor, so please excuse possible inprecsion in wording and lack of ER process understanding. Feel welcome to suggest corrections or improvements","title":"Conclusion &amp; Summary"},{"location":"examples/ferryman/","text":"A wild river, one boat only, and a patient ferryman transporting batches of passengers across the body of water. Covers: Batching to consume queue elements in defined blocks Monitors for stats and visualization Stanhope Forbes - A Ferryman at Flushing (oil on canvas, CC0 1.0) Simulation To form groups of passengers before passing the waters, we use batch() in the ferryman's process definition . It has multiple arguments: A mandatory queue with elements of type <T> to be consumed The size of the batch to be created. A positive integer is expected here. An optional timeout describing how long it shall wait before forming an incomplete/empty batch batch will return a list of type <T> of size batchSize or lesser (and potentially even empty) if timed out before filling the batch. ////Ferryman.kts package org.kalasim.examples import org.kalasim.* import org.kalasim.plot.kravis.display import org.kalasim.monitors.NumericStatisticMonitor createSimulation { class Passenger : Component () val fm = object : Component ( \"ferryman\" ) { val left2Right = ComponentQueue < Passenger > () val right2Left = ComponentQueue < Passenger > () val l2rMonitor = NumericStatisticMonitor () val r2lMonitor = NumericStatisticMonitor () override fun process () = sequence { val batchLR : List < Passenger > = batch ( left2Right , 4 , timeout = 10 ) l2rMonitor . addValue ( batchLR . size ) hold ( 5 , description = \"shipping ${ batchLR . size } l2r\" ) val batchRL : List < Passenger > = batch ( right2Left , 4 , timeout = 10 ) r2lMonitor . addValue ( batchRL . size ) hold ( 5 , description = \"shipping ${ batchRL . size } r2l\" ) // we could also use an infinite while loop instead of activate yield ( activate ( process = Component :: process )) } } ComponentGenerator ( uniform ( 0 , 15 )) { Passenger () } . addConsumer { fm . left2Right . add ( it ) } ComponentGenerator ( uniform ( 0 , 12 )) { Passenger () } . addConsumer { fm . right2Left . add ( it ) } run ( 10000 ) fm . l2rMonitor . display ( \"Passengers left->right\" ) fm . r2lMonitor . display ( \"Passengers right->left\" ) } Analysis The ferryman tries to max out his boat with 4 passengers, but after 10 minutes he will start anyway (even if the boat is entirely emtpy). kalasim will suspend execution when using batch() until timeout or indefinitely (if timeout is not set). Since both banks have different arrival distributions, we observe different batch-size patterns: Right\u2192Left Since passengers on the right bank arrive with a higher rate (that is shorter inter-arrival time between 0 and 12 ), the ferry is usually packed with people. Only occasionally the ferryman traverses from left to right banks with less than 4 passengers. Left\u2192Right Because of a slightly higher inter-arrival time (up to 15 minutes) on the left banks, it often happens that the ferry starts its journey across the river with some seats unoccupied. On average, just 3 seats are taken. However, at least during this simulation we did not encounter a passing with just the ferryman and his thoughts.","title":"The Ferryman"},{"location":"examples/ferryman/#simulation","text":"To form groups of passengers before passing the waters, we use batch() in the ferryman's process definition . It has multiple arguments: A mandatory queue with elements of type <T> to be consumed The size of the batch to be created. A positive integer is expected here. An optional timeout describing how long it shall wait before forming an incomplete/empty batch batch will return a list of type <T> of size batchSize or lesser (and potentially even empty) if timed out before filling the batch. ////Ferryman.kts package org.kalasim.examples import org.kalasim.* import org.kalasim.plot.kravis.display import org.kalasim.monitors.NumericStatisticMonitor createSimulation { class Passenger : Component () val fm = object : Component ( \"ferryman\" ) { val left2Right = ComponentQueue < Passenger > () val right2Left = ComponentQueue < Passenger > () val l2rMonitor = NumericStatisticMonitor () val r2lMonitor = NumericStatisticMonitor () override fun process () = sequence { val batchLR : List < Passenger > = batch ( left2Right , 4 , timeout = 10 ) l2rMonitor . addValue ( batchLR . size ) hold ( 5 , description = \"shipping ${ batchLR . size } l2r\" ) val batchRL : List < Passenger > = batch ( right2Left , 4 , timeout = 10 ) r2lMonitor . addValue ( batchRL . size ) hold ( 5 , description = \"shipping ${ batchRL . size } r2l\" ) // we could also use an infinite while loop instead of activate yield ( activate ( process = Component :: process )) } } ComponentGenerator ( uniform ( 0 , 15 )) { Passenger () } . addConsumer { fm . left2Right . add ( it ) } ComponentGenerator ( uniform ( 0 , 12 )) { Passenger () } . addConsumer { fm . right2Left . add ( it ) } run ( 10000 ) fm . l2rMonitor . display ( \"Passengers left->right\" ) fm . r2lMonitor . display ( \"Passengers right->left\" ) }","title":"Simulation"},{"location":"examples/ferryman/#analysis","text":"The ferryman tries to max out his boat with 4 passengers, but after 10 minutes he will start anyway (even if the boat is entirely emtpy). kalasim will suspend execution when using batch() until timeout or indefinitely (if timeout is not set). Since both banks have different arrival distributions, we observe different batch-size patterns: Right\u2192Left Since passengers on the right bank arrive with a higher rate (that is shorter inter-arrival time between 0 and 12 ), the ferry is usually packed with people. Only occasionally the ferryman traverses from left to right banks with less than 4 passengers. Left\u2192Right Because of a slightly higher inter-arrival time (up to 15 minutes) on the left banks, it often happens that the ferry starts its journey across the river with some seats unoccupied. On average, just 3 seats are taken. However, at least during this simulation we did not encounter a passing with just the ferryman and his thoughts.","title":"Analysis"},{"location":"examples/gas_station/","text":"Gas Station This example models a gas station and cars that arrive at the station for refueling. Covers: Depletable Resources Process Interaction, in particular waiting for other processes The gas station has a limited number of fuel pumps, and a fuel tank that is shared between the fuel pumps. The gas station is thus modeled as Resource . The shared fuel tank is modeled with a DepletableResource . Vehicles arriving at the gas station first request a fuel pump from the station. Once they acquire one, they try to take the desired amount of fuel from the fuel pump. They leave when they are done. The gas stations fuel level is regularly monitored by gas station control. When the level drops below a certain threshold, a tank truck is called to refuel the gas station itself. //package org.kalasim.examples import org.apache.commons.math3.distribution.UniformRealDistribution import org.kalasim.* import org.kalasim.misc.printThis import org.koin.core.component.get import org.koin.core.component.inject import org.koin.core.qualifier.named /** * A car arrives at the gas station for refueling. * * It requests one of the gas station's fuel pumps and tries to get the * desired amount of gas from it. If the stations reservoir is * depleted, the car has to wait for the tank truck to arrive. */ object GasStation { // based on SimPy example model val GAS_STATION_SIZE = 200.0 // liters val THRESHOLD = 25.0 // Threshold for calling the tank truck (in %) val FUEL_TANK_SIZE = 50.0 // liters val FUEL_TANK_LEVEL = UniformRealDistribution ( 5.0 , 25.0 ) // Min/max levels of fuel tanks (in liters) val REFUELING_SPEED = 2.0 // liters / second val TANK_TRUCK_TIME = 300.0 // Seconds it takes the tank truck to arrive val T_INTER = UniformRealDistribution ( 10.0 , 100.0 ) // Create a car every [min, max] seconds // val SIM_TIME = 200000.0 // Original Simulation time in seconds val SIM_TIME = 20000.0 // Simulation time in seconds private val FUEL_PUMP = \"fuel_pump\" @JvmStatic fun main ( args : Array < String > ) { class GasStation : Resource ( capacity = 2 ) class TankTruck : Component () { val fuelPump : DepletableResource by inject ( qualifier = named ( FUEL_PUMP )) override fun process () = sequence { hold ( TANK_TRUCK_TIME ) val amount = fuelPump . claimed put ( fuelPump withQuantity amount ) } } // we can either inject by constructor... class Car ( val gasStation : GasStation ) : Component () { // ... or we can inject by field which is // in particular useful for untypes resources and components // val gasStation : Resource by inject(qualifier = named(\"gas_station\")) val fuelPump : DepletableResource by inject ( qualifier = named ( FUEL_PUMP )) override fun process () = sequence { val fuelTankLevel = FUEL_TANK_LEVEL . sample () request ( gasStation ) val litersRequired = FUEL_TANK_SIZE - fuelTankLevel // order a new Tank if the fuelpump runs of out fuel if (( fuelPump . availableQuantity - litersRequired ) / fuelPump . capacity * 100 < THRESHOLD ) { log ( \"running out of fuel at $ gasStation . Ordering new fuel truck...\" ) TankTruck () } request ( fuelPump withQuantity litersRequired ) hold ( litersRequired / REFUELING_SPEED ) } } configureEnvironment ( true ) { // single(qualifier = named(\"gas_station\")) { Resource(\"gas_station\", 2) } single { GasStation () } single ( qualifier = named ( FUEL_PUMP )) { DepletableResource ( FUEL_PUMP , GAS_STATION_SIZE ) } }. apply { ComponentGenerator ( iat = T_INTER ) { Car ( get ()) } run ( SIM_TIME ) val fuelPump = get < DepletableResource > ( qualifier = named ( FUEL_PUMP )) fuelPump . apply { capacityTimeline . printHistogram () claimedTimeline . printHistogram () availabilityTimeline . printHistogram () // capacityTimeline.display() // claimedQuantityMonitor.display() // availableQuantityMonitor.display() } get < GasStation > (). requesters . apply { queueLengthMonitor . printThis () lengthOfStayMonitor . printThis () } } } } Here, we use both lazy injection with inject<T>() and instance retrieval with get<T>() . For details see koin reference The example is a true classic and was adopted from salabim 's and SimPy 's gas stations.","title":"Gas Station"},{"location":"examples/gas_station/#gas-station","text":"This example models a gas station and cars that arrive at the station for refueling. Covers: Depletable Resources Process Interaction, in particular waiting for other processes The gas station has a limited number of fuel pumps, and a fuel tank that is shared between the fuel pumps. The gas station is thus modeled as Resource . The shared fuel tank is modeled with a DepletableResource . Vehicles arriving at the gas station first request a fuel pump from the station. Once they acquire one, they try to take the desired amount of fuel from the fuel pump. They leave when they are done. The gas stations fuel level is regularly monitored by gas station control. When the level drops below a certain threshold, a tank truck is called to refuel the gas station itself. //package org.kalasim.examples import org.apache.commons.math3.distribution.UniformRealDistribution import org.kalasim.* import org.kalasim.misc.printThis import org.koin.core.component.get import org.koin.core.component.inject import org.koin.core.qualifier.named /** * A car arrives at the gas station for refueling. * * It requests one of the gas station's fuel pumps and tries to get the * desired amount of gas from it. If the stations reservoir is * depleted, the car has to wait for the tank truck to arrive. */ object GasStation { // based on SimPy example model val GAS_STATION_SIZE = 200.0 // liters val THRESHOLD = 25.0 // Threshold for calling the tank truck (in %) val FUEL_TANK_SIZE = 50.0 // liters val FUEL_TANK_LEVEL = UniformRealDistribution ( 5.0 , 25.0 ) // Min/max levels of fuel tanks (in liters) val REFUELING_SPEED = 2.0 // liters / second val TANK_TRUCK_TIME = 300.0 // Seconds it takes the tank truck to arrive val T_INTER = UniformRealDistribution ( 10.0 , 100.0 ) // Create a car every [min, max] seconds // val SIM_TIME = 200000.0 // Original Simulation time in seconds val SIM_TIME = 20000.0 // Simulation time in seconds private val FUEL_PUMP = \"fuel_pump\" @JvmStatic fun main ( args : Array < String > ) { class GasStation : Resource ( capacity = 2 ) class TankTruck : Component () { val fuelPump : DepletableResource by inject ( qualifier = named ( FUEL_PUMP )) override fun process () = sequence { hold ( TANK_TRUCK_TIME ) val amount = fuelPump . claimed put ( fuelPump withQuantity amount ) } } // we can either inject by constructor... class Car ( val gasStation : GasStation ) : Component () { // ... or we can inject by field which is // in particular useful for untypes resources and components // val gasStation : Resource by inject(qualifier = named(\"gas_station\")) val fuelPump : DepletableResource by inject ( qualifier = named ( FUEL_PUMP )) override fun process () = sequence { val fuelTankLevel = FUEL_TANK_LEVEL . sample () request ( gasStation ) val litersRequired = FUEL_TANK_SIZE - fuelTankLevel // order a new Tank if the fuelpump runs of out fuel if (( fuelPump . availableQuantity - litersRequired ) / fuelPump . capacity * 100 < THRESHOLD ) { log ( \"running out of fuel at $ gasStation . Ordering new fuel truck...\" ) TankTruck () } request ( fuelPump withQuantity litersRequired ) hold ( litersRequired / REFUELING_SPEED ) } } configureEnvironment ( true ) { // single(qualifier = named(\"gas_station\")) { Resource(\"gas_station\", 2) } single { GasStation () } single ( qualifier = named ( FUEL_PUMP )) { DepletableResource ( FUEL_PUMP , GAS_STATION_SIZE ) } }. apply { ComponentGenerator ( iat = T_INTER ) { Car ( get ()) } run ( SIM_TIME ) val fuelPump = get < DepletableResource > ( qualifier = named ( FUEL_PUMP )) fuelPump . apply { capacityTimeline . printHistogram () claimedTimeline . printHistogram () availabilityTimeline . printHistogram () // capacityTimeline.display() // claimedQuantityMonitor.display() // availableQuantityMonitor.display() } get < GasStation > (). requesters . apply { queueLengthMonitor . printThis () lengthOfStayMonitor . printThis () } } } } Here, we use both lazy injection with inject<T>() and instance retrieval with get<T>() . For details see koin reference The example is a true classic and was adopted from salabim 's and SimPy 's gas stations.","title":"Gas Station"},{"location":"examples/machine_parts/","text":"This model demonstrates the use of stacked interrupts. It is adopted from here . Each of two machines has three parts, that will be subject to failure. If one or more of these parts has failed, the machine is stopped. Only when all parts are operational, the machine can continue its work (hold). For a machine to work it needs the resource. If, during the requesting of this resource, one or more parts of that machine break down, the machine stops requesting until all parts are operational. In this model the interrupt level frequently gets to 2 or 3 (all parts broken down). Have a close look at the trace output to see what is going on. ////MachineWithParts.kt import org.kalasim.* class Part ( val machine : Machine , partNo : Int ) : Component ( name = machine . name . replace ( \"Machine\" , \"part\" ) + \". ${ partNo + 1 } \" ) { val ttf = uniform ( 19 , 20 ) // time to failure distribution val ttr = uniform ( 3 , 6 ) // time to repair distribution override fun process () = sequence { while ( true ) { hold ( ttf ()) machine . interrupt () hold ( ttr ()) machine . resume () } } } class Machine : Component () { init { repeat ( 3 ) { Part ( this , it ) } } override fun process () = sequence { while ( true ) { val r = get < Resource > () request ( r ) hold ( 5 ) release ( r ) } } } fun main () { createSimulation ( true ) { dependency { Resource () } repeat ( 2 ) { Machine () } run ( 400 ) } }","title":"Machine Parts"},{"location":"examples/machine_shop/","text":"In this example, we'll learn how to interrupt a process because of more important tasks. The example is adopted from the SimPy Machine Shop Example . The example covers interrupt and preemptive resources . The example comprises a workshop with n identical machines. A stream of jobs (enough to keep the machines busy) arrives. Each machine breaks down periodically. Repairs are carried out by one repairman. The repairman has other, less important tasks to perform, too. Broken machines preempt these tasks. The repairman continues them when he is done with the machine repair. The workshop works continuously. A machine has two processes: working implements the actual behaviour of the machine (producing parts). break_machine periodically interrupts the working process to simulate the machine failure. In kalasim there can only be one generating process per component. So to model the wear, we use a separate MachineWear which is interrupt ing the machine in case of failure. The repairman\u2019s other job is also a process (implemented by otherJob). The repairman itself is a preemptive resource with a capacity of 1 . The machine repairing has a priority of 1, while the other job has a priority of 2 (the smaller the number, the higher the priority). ////MachineShop.kt import org.apache.commons.math3.distribution.RealDistribution import org.kalasim.* val RANDOM_SEED : Int = 42 val PT_MEAN : Double = 10.0 // Avg. processing time in minutes val PT_SIGMA : Double = 2.0 // Sigma of processing time val MTTF : Double = 300.0 // Mean time to failure in minutes val REPAIR_TIME : Double = 30.0 // Time it takes to repair a machine in minutes val JOB_DURATION : Double = 30.0 // Duration of other jobs in minutes val NUM_MACHINES : Int = 10 // Number of machines in the machine shop val WEEKS : Int = 4 // Simulation time in weeks val SIM_TIME : Number = WEEKS * 7 * 24 * 60 // Simulation time in minutes fun main () { class Machine : Component () { var madeParts : Int = 0 private set val timePerPart : RealDistribution = normal ( PT_MEAN , PT_SIGMA ) override fun process (): Sequence < Component > = sequence { while ( true ) { // start working on a new part log ( \"building a new part\" ) hold ( timePerPart ()) log ( \"finished building part\" ) madeParts ++ } } } /** Break the machine every now and then. */ class MachineWear ( val machine : Machine , val repairMan : Resource ) : Component ( process = MachineWear :: breakMachine ) { fun breakMachine (): Sequence < Component > = sequence { val timeToFailure = exponential ( MTTF ) while ( true ) { hold ( timeToFailure ()) // handle the rare case that the model if ( machine . isInterrupted ) continue machine . interrupt () request ( repairMan ) hold ( REPAIR_TIME ) require ( ! isBumped ( repairMan )) { \"productive tools must not be bumped\" } release ( repairMan ) machine . resume () require ( ! machine . isInterrupted ) { \"machine must not be interrupted at end of wear cycle\" } } } } createSimulation ( true , randomSeed = RANDOM_SEED ) { val repairMan = Resource ( \"mechanic\" , preemptive = true ) // create N machines and wear components val tools = ( 1. . NUM_MACHINES ). map { Machine (). also { MachineWear ( it , repairMan ) } } // define the other jobs as object expression // https://kotlinlang.org/docs/reference/object-declarations.html#object-expressions object : Component ( \"side jobs\" ) { override fun process () = sequence { while ( true ) { request ( ResourceRequest ( repairMan , priority = Priority ( - 1 ))) hold ( JOB_DURATION ) if ( isBumped ( repairMan )) { log ( \"other job was bumped\" ) continue } release ( repairMan ) } } } // Run simulation run ( 1000 ) run ( SIM_TIME ) // Analysis tools . forEach { println ( \" ${ it . name } made ${ it . madeParts } parts.\" ) } } }","title":"Machine Shop"},{"location":"examples/movie_theater/","text":"Movie Theater Covers: Resources Event operators Shared events This example models a movie theater with one ticket counter selling tickets for three movies (next show only). People arrive at random times and try to buy a random number (1\u20136) tickets for a random movie. When a movie is sold out, all people waiting to buy a ticket for that movie renege (leave the queue). The movie theater is just a type to assemble all the related data (movies, the counter, tickets left, collected data, ...). The counter is a Resource with a capacity of one. The moviegoer process function starts waiting until either it\u2019s his turn (it acquires the counter resource) or until the sold out signal is triggered. If the latter is the case it reneges (leaves the queue). If it gets to the counter, it tries to buy some tickets. This might not be successful, e.g. if the process tries to buy 5 tickets but only 3 are left. If less than two tickets are left after the ticket purchase, the sold out signal is triggered. Moviegoers are generated by the customer arrivals process. It also chooses a movie, and the number of tickets for the moviegoer. ////MovieRenege.kt import org.kalasim.* import org.kalasim.misc.roundAny fun main () { val RANDOM_SEED = 158 val TICKETS = 50 // Number of tickets per movie val SIM_TIME = 120.0 // Simulate until data class Movie ( val name : String ) val MOVIES = listOf ( \"Julia Unchained\" , \"Kill Process\" , \"Pulp Implementation\" ). map { Movie ( it ) } createSimulation ( true , randomSeed = RANDOM_SEED ) { // note: it's not really needed to model the theater (because it has no process), but we follow the julia model here val theater = object { val tickets = MOVIES . associateWith { DepletableResource ( \"room ${ MOVIES . indexOf ( it ) } \" , capacity = TICKETS ) } val numReneged = MOVIES . associateWith { 0 }. toMutableMap () val counter = Resource ( \"counter\" , capacity = 1 ) } class Cineast ( val movie : Movie , val numTickets : Int ) : Component () { override fun process () = sequence { request ( theater . counter ) { request ( theater . tickets [ movie ]!! withQuantity numTickets , failAt = 0. tickTime ) if ( failed ) { theater . numReneged . merge ( movie , 1 , Int :: plus ) } } } } ComponentGenerator ( iat = exponential ( 0.5 )) { Cineast ( MOVIES . random (), discreteUniform ( 1 , 6 ). sample ()) } run ( SIM_TIME ) MOVIES . forEach { movie -> val numLeftQueue = theater . numReneged [ movie ]!! val soldOutSince = theater . tickets [ movie ]!! . occupancyTimeline . stepFun () // find the first time when tickets were sold out . first { it . second == 1.0 }. first . roundAny ( 2 ) println ( \"Movie ${ movie . name } sold out $ soldOutSince minutes after ticket counter opening.\" ) println ( \" $ numLeftQueue walked away after film was sold out.\" ) } // // Visualize ticket sales // val plotData = theater.tickets.values.flatMap { // it.occupancyTimeline.stepFun().map { sf -> Triple(it.name, sf.first, sf.second) } // } // // plotData.asDataFrame().plot(x = \"second\", y = \"third\") // .geomStep().facetWrap(\"first\").title(\"Theater Occupancy\") // .xLabel(\"Time (min)\").yLabel(\"Occupancy\") } } The example also details out how we could now easily plot the occupancy progressions using automatically captured monitoring data. Adopted from SimJulia example .","title":"Movie Theater"},{"location":"examples/movie_theater/#movie-theater","text":"Covers: Resources Event operators Shared events This example models a movie theater with one ticket counter selling tickets for three movies (next show only). People arrive at random times and try to buy a random number (1\u20136) tickets for a random movie. When a movie is sold out, all people waiting to buy a ticket for that movie renege (leave the queue). The movie theater is just a type to assemble all the related data (movies, the counter, tickets left, collected data, ...). The counter is a Resource with a capacity of one. The moviegoer process function starts waiting until either it\u2019s his turn (it acquires the counter resource) or until the sold out signal is triggered. If the latter is the case it reneges (leaves the queue). If it gets to the counter, it tries to buy some tickets. This might not be successful, e.g. if the process tries to buy 5 tickets but only 3 are left. If less than two tickets are left after the ticket purchase, the sold out signal is triggered. Moviegoers are generated by the customer arrivals process. It also chooses a movie, and the number of tickets for the moviegoer. ////MovieRenege.kt import org.kalasim.* import org.kalasim.misc.roundAny fun main () { val RANDOM_SEED = 158 val TICKETS = 50 // Number of tickets per movie val SIM_TIME = 120.0 // Simulate until data class Movie ( val name : String ) val MOVIES = listOf ( \"Julia Unchained\" , \"Kill Process\" , \"Pulp Implementation\" ). map { Movie ( it ) } createSimulation ( true , randomSeed = RANDOM_SEED ) { // note: it's not really needed to model the theater (because it has no process), but we follow the julia model here val theater = object { val tickets = MOVIES . associateWith { DepletableResource ( \"room ${ MOVIES . indexOf ( it ) } \" , capacity = TICKETS ) } val numReneged = MOVIES . associateWith { 0 }. toMutableMap () val counter = Resource ( \"counter\" , capacity = 1 ) } class Cineast ( val movie : Movie , val numTickets : Int ) : Component () { override fun process () = sequence { request ( theater . counter ) { request ( theater . tickets [ movie ]!! withQuantity numTickets , failAt = 0. tickTime ) if ( failed ) { theater . numReneged . merge ( movie , 1 , Int :: plus ) } } } } ComponentGenerator ( iat = exponential ( 0.5 )) { Cineast ( MOVIES . random (), discreteUniform ( 1 , 6 ). sample ()) } run ( SIM_TIME ) MOVIES . forEach { movie -> val numLeftQueue = theater . numReneged [ movie ]!! val soldOutSince = theater . tickets [ movie ]!! . occupancyTimeline . stepFun () // find the first time when tickets were sold out . first { it . second == 1.0 }. first . roundAny ( 2 ) println ( \"Movie ${ movie . name } sold out $ soldOutSince minutes after ticket counter opening.\" ) println ( \" $ numLeftQueue walked away after film was sold out.\" ) } // // Visualize ticket sales // val plotData = theater.tickets.values.flatMap { // it.occupancyTimeline.stepFun().map { sf -> Triple(it.name, sf.first, sf.second) } // } // // plotData.asDataFrame().plot(x = \"second\", y = \"third\") // .geomStep().facetWrap(\"first\").title(\"Theater Occupancy\") // .xLabel(\"Time (min)\").yLabel(\"Occupancy\") } } The example also details out how we could now easily plot the occupancy progressions using automatically captured monitoring data. Adopted from SimJulia example .","title":"Movie Theater"},{"location":"examples/office_tower/","text":"Here, we simulate logistics in an office tower. There are 3 lifts with capacity limited cars. Passengers arrive at different floors with different rates and press buttons indicating the direction of their target floor. The cars have a defined speed, and clearly it takes time to open/close its doors before passengers can enter & leaver. Parameters Origin/destination distribution of visitors Number of elevators Capacity of each elevator See here for the implementation The implementation is inspired by salabim's elevator example.","title":"Office Tower"},{"location":"examples/traffic/","text":"The following example integrates three simulation entities A gas station with a limited number of pumps A traffic light that prevents cars from driving Multiple cars that need to pass the cross with the traffic light to reach a gas station. There each car needs to refill before it is reaching its end of live within the simulation context. The example illustrates how to establish a simple interplay of states and resources . It is realized elegantly with dependency injection . ////Traffic.kts import org.kalasim.* import org.koin.core.component.get import org.koin.core.component.inject class TrafficLight : State < String > ( \"red\" ) class GasStation ( numPumps : Int = 6 ) : Resource ( capacity = numPumps ) class Car ( val trafficLight : TrafficLight ) : Component () { val gasStation by inject < GasStation > () override fun process () = sequence { // wait until the traffic light is green wait ( trafficLight , \"green\" ) // request a slot in the gas-station request ( gasStation ) // refill hold ( 5 ) // release pump release ( gasStation ) // change state of car to DATA passivate () } } class Car2 : Component () { val gasStation by inject < GasStation > () override fun process () = sequence { // wait until the traffic light is green request ( gasStation ) { hold ( 2 , \"refill\" ) } val trafficLight = get < TrafficLight > () wait ( trafficLight , \"green\" ) } } createSimulation ( true ) { // Add a traffic light so that we can refer to it via koin get<T>() dependency { TrafficLight () } // Also add a resource with a limited capacity dependency { GasStation ( 2 ) } val car1 = Car ( get ()) val car2 = Car ( get ()) val car3 = Car ( get ()) // run for 10 ticks run ( 10 ) // toggle the traffic light get < TrafficLight > (). value = \"green\" // run for another 10 ticks run ( 10 ) // assess the state of the simulation entities car2 . statusTimeline . printHistogram () get < GasStation > (). printStatistics () } Here, we use both lazy injection with inject<T>() and instance retrieval with get<T>() . For details see koin reference","title":"Traffic"}]}